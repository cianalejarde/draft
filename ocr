// tesseractOCR.js
import Tesseract from 'tesseract.js';

/**
 * Enhanced auto-detection config for full-frame scanning
 */
const AUTO_DETECTION_CONFIG = {
  STABILITY_THRESHOLD: 400,
  CAPTURE_COOLDOWN: 4000,
  MIN_CONTOUR_AREA: 30000,
  ASPECT_RATIO_MIN: 1.5,
  ASPECT_RATIO_MAX: 1.7,
  EDGE_DENSITY_THRESHOLD: 0.12,
  BLUR_THRESHOLD: 120,
  CONFIDENCE_THRESHOLD: 0.70,
  STABLE_FRAMES_REQUIRED: 3,
  FRAME_INTERVAL: 250
};

/**
 * OCR configuration optimized for Philippine IDs
 */
const OCR_CONFIG = {
  lang: 'eng',
  oem: 1,
  psm: 6,
  tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 -.,/\':',
  tessedit_pageseg_mode: 6
};

/**
 * Check if camera is available
 */
export const isCameraAvailable = () => {
  return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
};

/**
 * Initialize camera stream
 */
export const initializeCamera = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: 'environment',
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      }
    });
    return stream;
  } catch (error) {
    console.error('Camera initialization error:', error);
    throw error;
  }
};

/**
 * Cleanup camera stream
 */
export const cleanupCamera = (stream) => {
  if (stream) {
    stream.getTracks().forEach(track => track.stop());
  }
};

/**
 * Capture image from video element
 */
export const captureImageFromVideo = (video) => {
  try {
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    return canvas.toDataURL('image/jpeg', 0.95);
  } catch (error) {
    console.error('Image capture error:', error);
    return null;
  }
};

/**
 * Verify ID is in frame
 */
const verifyIDInFrame = async (imageData) => {
  return { valid: true };
};

/**
 * Detect ID in frame
 */
export const detectIDInFrame = async (imageData) => {
  return { detected: true, confidence: 0.85 };
};

/**
 * Crop and preprocess ID
 */
export const cropAndPreprocessID = async (imageData) => {
  return imageData;
};

/**
 * Start auto capture
 */
export const startAutoCapture = (callback) => {
  console.log('Auto-capture feature initiated');
};

/**
 * Enhanced preprocessing techniques
 */
export const preprocessingTechniques = {
  grayscale: (imageData) => {
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
      data[i] = data[i + 1] = data[i + 2] = gray;
    }
    return imageData;
  },

  binaryThreshold: (imageData, threshold = 128) => {
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      const gray = data[i];
      const binary = gray > threshold ? 255 : 0;
      data[i] = data[i + 1] = data[i + 2] = binary;
    }
    return imageData;
  },

  adaptiveThreshold: (imageData, blockSize = 25, C = 12) => {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const output = new Uint8ClampedArray(data);
    
    const halfBlock = Math.floor(blockSize / 2);
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let sum = 0;
        let count = 0;
        
        for (let dy = -halfBlock; dy <= halfBlock; dy++) {
          for (let dx = -halfBlock; dx <= halfBlock; dx++) {
            const ny = y + dy;
            const nx = x + dx;
            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
              const idx = (ny * width + nx) * 4;
              sum += data[idx];
              count++;
            }
          }
        }
        
        const avg = sum / count;
        const idx = (y * width + x) * 4;
        const binary = data[idx] > (avg - C) ? 255 : 0;
        output[idx] = output[idx + 1] = output[idx + 2] = binary;
      }
    }
    
    for (let i = 0; i < data.length; i++) {
      data[i] = output[i];
    }
    
    return imageData;
  },

  dilate: (imageData, iterations = 1) => {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    
    for (let iter = 0; iter < iterations; iter++) {
      const output = new Uint8ClampedArray(data);
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          let maxVal = 0;
          
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const idx = ((y + dy) * width + (x + dx)) * 4;
              maxVal = Math.max(maxVal, data[idx]);
            }
          }
          
          const idx = (y * width + x) * 4;
          output[idx] = output[idx + 1] = output[idx + 2] = maxVal;
        }
      }
      
      for (let i = 0; i < data.length; i++) {
        data[i] = output[i];
      }
    }
    
    return imageData;
  },

  sharpen: (imageData) => {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const output = new Uint8ClampedArray(data);
    
    const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
    
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        let sum = 0;
        let ki = 0;
        
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const idx = ((y + dy) * width + (x + dx)) * 4;
            sum += data[idx] * kernel[ki];
            ki++;
          }
        }
        
        const idx = (y * width + x) * 4;
        const value = Math.max(0, Math.min(255, sum));
        output[idx] = output[idx + 1] = output[idx + 2] = value;
      }
    }
    
    for (let i = 0; i < data.length; i++) {
      data[i] = output[i];
    }
    
    return imageData;
  },

  contrastEnhancement: (imageData, factor = 1.5) => {
    const data = imageData.data;
    const contrast = (factor - 1) * 128;
    
    for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.max(0, Math.min(255, factor * data[i] + contrast));
      data[i + 1] = Math.max(0, Math.min(255, factor * data[i + 1] + contrast));
      data[i + 2] = Math.max(0, Math.min(255, factor * data[i + 2] + contrast));
    }
    return imageData;
  },

  medianFilter: (imageData, radius = 1) => {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const output = new Uint8ClampedArray(data);
    
    for (let y = radius; y < height - radius; y++) {
      for (let x = radius; x < width - radius; x++) {
        const neighbors = [];
        
        for (let dy = -radius; dy <= radius; dy++) {
          for (let dx = -radius; dx <= radius; dx++) {
            const idx = ((y + dy) * width + (x + dx)) * 4;
            neighbors.push(data[idx]);
          }
        }
        
        neighbors.sort((a, b) => a - b);
        const median = neighbors[Math.floor(neighbors.length / 2)];
        
        const idx = (y * width + x) * 4;
        output[idx] = output[idx + 1] = output[idx + 2] = median;
      }
    }
    
    for (let i = 0; i < data.length; i++) {
      data[i] = output[i];
    }
    
    return imageData;
  }
};

/**
 * Generate canvas preprocessing variations
 */
const generateCanvasPreprocessingVariations = async (imageBase64) => {
  const variations = [];
  
  // Original
  variations.push(imageBase64);
  
  // Create canvas variations
  const img = new Image();
  img.src = imageBase64;
  
  await new Promise((resolve) => {
    img.onload = resolve;
  });
  
  const canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  
  // Variation with contrast
  ctx.drawImage(img, 0, 0);
  let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  imageData = preprocessingTechniques.contrastEnhancement(imageData, 1.5);
  ctx.putImageData(imageData, 0, 0);
  variations.push(canvas.toDataURL('image/jpeg', 0.95));
  
  return variations;
};

/**
 * Select best OCR result
 */
const selectBestOCRResult = (results) => {
  return results.reduce((best, current) => {
    return current.confidence > best.confidence ? current : best;
  });
};

/**
 * Filter out noisy OCR lines - keep only readable text
 */
const filterNoiseLines = (lines) => {
  return lines.filter(line => {
    const cleanLine = line.replace(/\s+/g, ' ').trim();
    
    // Skip empty lines
    if (cleanLine.length === 0) return false;
    
    // Skip lines with too many non-letter characters (noise indicators)
    const letterCount = (cleanLine.match(/[A-Z]/g) || []).length;
    const totalLength = cleanLine.length;
    const letterRatio = letterCount / totalLength;
    
    // If less than 50% letters, it's likely noise
    if (letterRatio < 0.5) return false;
    
    // Skip lines with excessive noise characters
    const noiseChars = (cleanLine.match(/[\[\]\{\}\(\)\|\=\+\*\@\#\$\%\^\&]/g) || []).length;
    if (noiseChars > 3) return false;
    
    // Skip very short lines (less than 5 chars) or extremely long lines (noise)
    if (cleanLine.length < 5 || cleanLine.length > 100) return false;
    
    return true;
  });
};

/**
 * PhilHealth Name Extraction - REVISED VERSION
 * Input Format: "LEJARDE, JERELYN MANGADLAO" (SURNAME, FIRSTNAME MIDDLENAME)
 * Output Format: "JERELYN MANGADLAO LEJARDE" (FIRSTNAME MIDDLENAME SURNAME)
 */
const extractPhilHealthName = (lines) => {
  console.log('üìã PhilHealth ID detected');
  console.log('üìÑ All Lines:', lines);
  
  const cleanLines = filterNoiseLines(lines);
  console.log('üìÑ Clean Lines:', cleanLines);
  
  // PhilHealth format: "SURNAME, FIRSTNAME MIDDLENAME"
  const namePattern = /^([A-Z][A-Z\s\-']{1,25})\s*,\s*([A-Z][A-Z\s\-']{3,40})$/;
  
  for (let i = 0; i < cleanLines.length; i++) {
    let line = cleanLines[i];
    
    // Clean the line - remove noise characters
    let cleanLine = line
      .replace(/[|\\\/\=\+\*\@\#\$\%\^\&\[\]\{\}\(\)]/g, ' ')
      .replace(/\s+/g, ' ')
      .replace(/^[0-9IVX\$\&\-\s]+/, '')
      .replace(/[0-9IVX\$\&\-\s]+$/, '')
      .trim();
    
    console.log('üîç Checking line for name:', cleanLine);
    
    // Skip non-name lines
    if (cleanLine.includes('PHILHEALTH') || 
        cleanLine.includes('PHILIPPINE') ||
        cleanLine.includes('REPUBLIC') ||
        cleanLine.includes('HEALTH') ||
        cleanLine.includes('INSURANCE') ||
        cleanLine.includes('CORPORATION') ||
        cleanLine.includes('STREET') ||
        cleanLine.includes('BARANGAY') ||
        cleanLine.includes('BGY') ||
        cleanLine.includes('BRGY') ||
        cleanLine.includes('DISTRICT') ||
        cleanLine.includes('CITY') ||
        cleanLine.includes('PROVINCE') ||
        cleanLine.includes('MANILA') ||
        cleanLine.includes('MEMBER') ||
        cleanLine.includes('DEPENDENT') ||
        cleanLine.includes('SIGNATURE') ||
        /\d{2}[-\s]?\d{9}[-\s]?\d/.test(cleanLine) ||
        /\d{4}[-\/]\d{2}[-\/]\d{2}/.test(cleanLine) ||
        /(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)\s+\d{1,2}/i.test(cleanLine) ||
        cleanLine.includes('FEMALE') ||
        cleanLine.includes('MALE') ||
        cleanLine.length < 8 ||
        cleanLine.length > 50) {
      continue;
    }
    
    // Must have a comma for PhilHealth name format
    if (!cleanLine.includes(',')) {
      continue;
    }
    
    const match = cleanLine.match(namePattern);
    if (match) {
      const surname = match[1].trim();
      const firstMiddle = match[2].trim();
      
      console.log('üîç Potential match - Surname:', surname, 'First+Middle:', firstMiddle);
      
      // Validate: no numbers or special chars in name
      if (!/[0-9\{\}\[\]\(\)\=\|\+\*\@\#\$\%\^\&]/.test(surname) &&
          !/[0-9\{\}\[\]\(\)\=\|\+\*\@\#\$\%\^\&]/.test(firstMiddle)) {
        
        const surnameWords = surname.split(/\s+/).filter(w => w.length > 0);
        const firstMiddleWords = firstMiddle.split(/\s+/).filter(w => w.length > 0);
        
        // Surname: 1-2 words, First+Middle: 2-4 words
        if (surnameWords.length >= 1 && surnameWords.length <= 2 &&
            firstMiddleWords.length >= 2 && firstMiddleWords.length <= 4 &&
            surname.length >= 2 && surname.length <= 25 &&
            firstMiddle.length >= 4 && firstMiddle.length <= 40) {
          
          // Output Format: FIRSTNAME MIDDLENAME SURNAME
          const fullName = `${firstMiddle} ${surname}`;
          console.log('‚úÖ Extracted Full Name (First Middle Surname):', fullName);
          return fullName;
        }
      }
    }
  }
  
  // Fallback: Try to find name near the ID number
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // If this line looks like an ID number, check the next line for name
    if (/\d{2}[-\s]?\d{9}[-\s]?\d/.test(line)) {
      const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
      
      if (nextLine && nextLine.includes(',')) {
        const cleanNext = nextLine
          .replace(/[|\\\/\=\+\*\@\#\$\%\^\&\[\]\{\}\(\)]/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
        
        const match = cleanNext.match(namePattern);
        if (match) {
          const surname = match[1].trim();
          const firstMiddle = match[2].trim();
          
          // Output Format: FIRSTNAME MIDDLENAME SURNAME
          const fullName = `${firstMiddle} ${surname}`;
          console.log('‚úÖ Extracted Full Name (after ID number):', fullName);
          return fullName;
        }
      }
    }
  }
  
  console.log('‚ùå No valid PhilHealth name found');
  return null;
};

/**
 * PhilHealth Sex Extraction - IMPROVED VERSION
 * Format: "APRIL 15, 1978 - FEMALE" (same line as birthday, after dash)
 */
const extractPhilHealthSex = (lines) => {
  console.log('üë§ Extracting PhilHealth Sex');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Pattern 1: Date followed by dash and sex
    const sexAfterDatePattern = /(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)\s+\d{1,2},?\s+\d{4}\s*[-‚Äì‚Äî]\s*(MALE|FEMALE)/i;
    const sexMatch = line.match(sexAfterDatePattern);
    
    if (sexMatch) {
      const sex = sexMatch[2].toUpperCase() === 'FEMALE' ? 'Female' : 'Male';
      console.log('‚úÖ Found Sex (after date):', sex);
      return sex;
    }
    
    // Pattern 2: Line ends with MALE or FEMALE
    const lineUpper = line.toUpperCase().trim();
    if (lineUpper.endsWith('FEMALE')) {
      console.log('‚úÖ Found Sex (line ends with FEMALE):', 'Female');
      return 'Female';
    }
    if (lineUpper.endsWith('MALE') && !lineUpper.endsWith('FEMALE')) {
      console.log('‚úÖ Found Sex (line ends with MALE):', 'Male');
      return 'Male';
    }
    
    // Pattern 3: Dash followed by sex anywhere in line
    const dashSexPattern = /[-‚Äì‚Äî]\s*(MALE|FEMALE)/i;
    const dashMatch = line.match(dashSexPattern);
    if (dashMatch) {
      const sex = dashMatch[1].toUpperCase() === 'FEMALE' ? 'Female' : 'Male';
      console.log('‚úÖ Found Sex (after dash):', sex);
      return sex;
    }
    
    // Pattern 4: Standalone MALE or FEMALE on a line (after a date line)
    if (lineUpper === 'FEMALE' || lineUpper === 'MALE') {
      if (i > 0) {
        const prevLine = lines[i - 1];
        if (/(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)\s+\d{1,2}/i.test(prevLine) ||
            /\d{4}/.test(prevLine)) {
          const sex = lineUpper === 'FEMALE' ? 'Female' : 'Male';
          console.log('‚úÖ Found Sex (standalone after date):', sex);
          return sex;
        }
      }
    }
  }
  
  console.log('‚ùå No PhilHealth sex found');
  return null;
};

/**
 * PhilHealth Birthday Extraction - REVISED VERSION
 * Input Format: "APRIL 15, 1978" (MONTH DAY, YEAR)
 * Output Format: "04-15-1978" (MM-DD-YYYY)
 */
const extractPhilHealthBirthday = (lines) => {
  console.log('üìÖ Extracting PhilHealth Birthday');
  
  // Month name to number conversion
  const monthNames = {
    'JANUARY': '01', 'FEBRUARY': '02', 'MARCH': '03', 'APRIL': '04',
    'MAY': '05', 'JUNE': '06', 'JULY': '07', 'AUGUST': '08',
    'SEPTEMBER': '09', 'OCTOBER': '10', 'NOVEMBER': '11', 'DECEMBER': '12'
  };
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Pattern: "MONTH DAY, YEAR" or "MONTH DAY YEAR"
    // Examples: "APRIL 15, 1978", "APRIL 15, 1978 - FEMALE"
    const datePattern = /(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)\s+(\d{1,2}),?\s+(\d{4})/i;
    const match = line.match(datePattern);
    
    if (match) {
      const monthText = match[1].toUpperCase();
      const day = match[2].padStart(2, '0');
      const year = match[3];
      const month = monthNames[monthText];
      
      if (month) {
        // Validate year is reasonable for a birthday
        const yearInt = parseInt(year);
        if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
          // Output Format: MM-DD-YYYY
          const formattedDate = `${month}-${day}-${year}`;
          console.log('‚úÖ Found Birthday (MM-DD-YYYY):', formattedDate);
          return formattedDate;
        }
      }
    }
    
    // Pattern 2: Check combined lines
    if (i + 1 < lines.length) {
      const combinedLine = line + ' ' + lines[i + 1];
      const combinedMatch = combinedLine.match(datePattern);
      
      if (combinedMatch) {
        const monthText = combinedMatch[1].toUpperCase();
        const day = combinedMatch[2].padStart(2, '0');
        const year = combinedMatch[3];
        const month = monthNames[monthText];
        
        if (month) {
          const yearInt = parseInt(year);
          if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
            // Output Format: MM-DD-YYYY
            const formattedDate = `${month}-${day}-${year}`;
            console.log('‚úÖ Found Birthday (combined, MM-DD-YYYY):', formattedDate);
            return formattedDate;
          }
        }
      }
    }
  }
  
  // Fallback: Look for numeric date patterns and convert
  for (let line of lines) {
    // Skip address lines
    if (line.includes('STREET') || line.includes('BGY') || 
        line.includes('BRGY') || line.includes('DISTRICT')) {
      continue;
    }
    
    // Pattern: YYYY-MM-DD (convert to MM-DD-YYYY)
    const isoPattern = /(\d{4})[-\/](\d{2})[-\/](\d{2})/;
    const isoMatch = line.match(isoPattern);
    if (isoMatch) {
      const year = isoMatch[1];
      const month = isoMatch[2];
      const day = isoMatch[3];
      const yearInt = parseInt(year);
      
      if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
        // Output Format: MM-DD-YYYY
        const formattedDate = `${month}-${day}-${year}`;
        console.log('‚úÖ Found Birthday (converted from ISO, MM-DD-YYYY):', formattedDate);
        return formattedDate;
      }
    }
    
    // Pattern: MM/DD/YYYY or MM-DD-YYYY (already correct format, just normalize separator)
    const mmddPattern = /(\d{2})[-\/](\d{2})[-\/](\d{4})/;
    const mmddMatch = line.match(mmddPattern);
    if (mmddMatch) {
      const part1 = mmddMatch[1];
      const part2 = mmddMatch[2];
      const year = mmddMatch[3];
      const yearInt = parseInt(year);
      
      if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
        // Assume MM-DD-YYYY format
        const formattedDate = `${part1}-${part2}-${year}`;
        console.log('‚úÖ Found Birthday (numeric, MM-DD-YYYY):', formattedDate);
        return formattedDate;
      }
    }
  }
  
  console.log('‚ùå No PhilHealth birthday found');
  return null;
};

/**
 * PhilHealth Address Extraction - IMPROVED VERSION
 * Format: "1503-D FABIE STREET BGY 815 PACO, SIXTH DISTRICT"
 */
const extractPhilHealthAddress = (lines) => {
  console.log('üè† Extracting PhilHealth Address');
  
  let addressCandidates = [];
  
  // Address keywords
  const addressKeywords = [
    'STREET', 'ST.', 'ST ',
    'AVENUE', 'AVE.', 'AVE ',
    'ROAD', 'RD.', 'RD ',
    'BOULEVARD', 'BLVD',
    'DRIVE', 'DR.',
    'LANE', 'LN.',
    'BGY', 'BRGY', 'BARANGAY',
    'DISTRICT', 'ZONE', 'PUROK',
    'SUBDIVISION', 'SUBD', 'VILL', 'VILLAGE',
    'COMPOUND', 'BLDG', 'BUILDING',
    'PHASE', 'BLOCK', 'LOT', 'FLOOR'
  ];
  
  // City/Location keywords
  const locationKeywords = [
    'MANILA', 'QUEZON', 'MAKATI', 'PASIG', 'TAGUIG', 'PASAY',
    'CALOOCAN', 'MARIKINA', 'MUNTINLUPA', 'PARANAQUE', 'LAS PINAS',
    'VALENZUELA', 'MALABON', 'NAVOTAS', 'PATEROS',
    'PACO', 'TONDO', 'SAMPALOC', 'SANTA ANA', 'ERMITA', 'MALATE',
    'INTRAMUROS', 'BINONDO', 'QUIAPO', 'SAN MIGUEL',
    'NCR', 'METRO MANILA'
  ];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineUpper = line.toUpperCase();
    
    // Skip non-address lines
    if (lineUpper.includes('PHILHEALTH') ||
        lineUpper.includes('PHILIPPINE') ||
        lineUpper.includes('HEALTH') ||
        lineUpper.includes('INSURANCE') ||
        lineUpper.includes('CORPORATION') ||
        lineUpper.includes('REPUBLIC') ||
        lineUpper.includes('MEMBER') ||
        lineUpper.includes('DEPENDENT') ||
        lineUpper.includes('SIGNATURE') ||
        /^\d{2}[-\s]?\d{9}[-\s]?\d$/.test(line.replace(/\s/g, '')) ||
        /^[A-Z]+,\s*[A-Z\s]+$/.test(line) ||
        /(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)\s+\d{1,2},?\s+\d{4}/i.test(line) ||
        lineUpper === 'FEMALE' ||
        lineUpper === 'MALE' ||
        line.length < 10) {
      continue;
    }
    
    // Score the line
    let score = 0;
    let hasAddressKeyword = false;
    let hasLocationKeyword = false;
    let hasNumber = /\d/.test(line);
    
    for (const keyword of addressKeywords) {
      if (lineUpper.includes(keyword)) {
        hasAddressKeyword = true;
        score += 3;
        break;
      }
    }
    
    for (const location of locationKeywords) {
      if (lineUpper.includes(location)) {
        hasLocationKeyword = true;
        score += 2;
        break;
      }
    }
    
    if (hasNumber) score += 2;
    
    // Pattern: Number followed by text
    if (/^\d+[-\s]?[A-Z]?\s+[A-Z]/.test(lineUpper)) {
      score += 3;
    }
    
    // Pattern: Building/Unit number like "1503-D"
    if (/\d+[-\s]?[A-Z]/.test(line)) {
      score += 2;
    }
    
    if (score >= 3 || hasAddressKeyword || (hasLocationKeyword && hasNumber)) {
      let cleaned = line
        .replace(/\s+/g, ' ')
        .replace(/[=\|]+/g, '')
        .replace(/PACQO/g, 'PACO')
        .replace(/DIST\s*RIC\s*R?/gi, 'DISTRICT')
        .trim()
        .replace(/\s*,\s*$/, '');
      
      addressCandidates.push({
        line: cleaned,
        score: score,
        index: i
      });
    }
  }
  
  console.log('üìç Address candidates:', addressCandidates);
  
  if (addressCandidates.length === 0) {
    console.log('‚ùå No PhilHealth address found');
    return null;
  }
  
  // Sort by score
  addressCandidates.sort((a, b) => b.score - a.score);
  
  // Combine consecutive lines if applicable
  const bestCandidate = addressCandidates[0];
  let fullAddress = bestCandidate.line;
  
  for (const candidate of addressCandidates) {
    if (candidate.index === bestCandidate.index + 1 && candidate.score >= 2) {
      fullAddress += ', ' + candidate.line;
      break;
    }
  }
  
  console.log('‚úÖ Found Address:', fullAddress);
  return fullAddress;
};

/**
 * PhilHealth ID Number Extraction
 * Format: "19-025542778-8" (XX-XXXXXXXXX-X)
 */
const extractPhilHealthIDNumber = (lines) => {
  console.log('üî¢ Extracting PhilHealth ID Number');
  
  for (let line of lines) {
    // Pattern: XX-XXXXXXXXX-X (2 digits - 9 digits - 1 digit)
    const idPattern = /\b(\d{2})[-\s]?(\d{9})[-\s]?(\d)\b/;
    const match = line.match(idPattern);
    
    if (match) {
      const idNumber = `${match[1]}-${match[2]}-${match[3]}`;
      console.log('‚úÖ Found PhilHealth ID Number:', idNumber);
      return idNumber;
    }
  }
  
  console.log('‚ùå No PhilHealth ID number found');
  return null;
};

/**
 * Driver's License Name Extraction - ENHANCED for Full Format
 */
const extractDrivingLicenseName = (lines) => {
  console.log('üìã Driver\'s License detected');
  console.log('üìÑ Lines:', lines);
  
  // Driver's License format: "LAST NAME, FIRST NAME MIDDLE NAME"
  // Example: "MENDOZA, ROSS JOHN ESTACIO"
  
  const nameWithCommaPattern = /^([A-Z\s]+),\s*([A-Z\s]+)$/;
  
  for (let line of lines) {
    // Skip header lines, labels, and system information
    if (line.includes('LICENSE') || 
        line.includes('DRIVER') ||
        line.includes('LTO') ||
        line.includes('REPUBLIC') ||
        line.includes('PHILIPPINES') ||
        line.includes('DEPARTMENT') ||
        line.includes('TRANSPORTATION') ||
        line.includes('LAND') ||
        line.includes('OFFICE') ||
        line.includes('LAST NAME') ||
        line.includes('FIRST NAME') ||
        line.includes('MIDDLE NAME') ||
        line.includes('NATIONALITY') ||
        line.includes('ADDRESS') ||
        line.includes('LICENSE NO') ||
        line.includes('EXPIRATION') ||
        line.includes('BLOOD TYPE') ||
        line.includes('EYES COLOR') ||
        line.includes('CONDITIONS') ||
        line.includes('SIGNATURE') ||
        /^N\d{2}-\d{2}-\d{6}$/.test(line) || // License number format
        /^\d{4}\/\d{2}\/\d{2}$/.test(line) || // Date format
        line.length < 5) {
      continue;
    }
    
    // Look for comma-separated name format: "SURNAME, FIRSTNAME MIDDLENAME"
    const match = line.match(nameWithCommaPattern);
    if (match) {
      const surname = match[1].trim();
      const firstMiddle = match[2].trim();
      
      const surnameWords = surname.split(/\s+/);
      const firstMiddleWords = firstMiddle.split(/\s+/);
      
      // Validate: surname should be 1-3 words, first+middle should be 2-5 words
      if (surnameWords.length >= 1 && surnameWords.length <= 3 &&
          firstMiddleWords.length >= 2 && firstMiddleWords.length <= 5 &&
          surname.length >= 2 && firstMiddle.length >= 4) {
        
        // Reconstruct as: First Middle Surname
        const fullName = `${firstMiddle} ${surname}`;
        console.log('‚úÖ Extracted Full Name:', fullName);
        return fullName;
      }
    }
  }
  
  return null;
};

/**
 * Driver's License Sex Extraction - NEW FUNCTION
 */
const extractDriversLicenseSex = (lines) => {
  console.log('üë§ Extracting Driver\'s License Sex');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
    
    // Look for "Sex" label
    if (line.includes('SEX')) {
      // Sex might be on the same line or next line
      
      // Check current line for M/F after "Sex"
      const sexMatch = line.match(/SEX[:\s]*([MF])/i);
      if (sexMatch) {
        const sex = sexMatch[1].toUpperCase() === 'M' ? 'Male' : 'Female';
        console.log('‚úÖ Found Sex (same line):', sex);
        return sex;
      }
      
      // Check next line
      if (nextLine) {
        const nextSexMatch = nextLine.match(/^([MF])$/i);
        if (nextSexMatch) {
          const sex = nextSexMatch[1].toUpperCase() === 'M' ? 'Male' : 'Female';
          console.log('‚úÖ Found Sex (next line):', sex);
          return sex;
        }
      }
    }
    
    // Direct M or F pattern with context (nationality line)
    // Format: "PHL     M     2004/04/29"
    const contextPattern = /^(PHL|FILIPINO)\s+([MF])\s+\d{4}\/\d{2}\/\d{2}/i;
    const contextMatch = line.match(contextPattern);
    if (contextMatch) {
      const sex = contextMatch[2].toUpperCase() === 'M' ? 'Male' : 'Female';
      console.log('‚úÖ Found Sex (context pattern):', sex);
      return sex;
    }
  }
  
  return null;
};

/**
 * Driver's License Birthday Extraction - NEW FUNCTION
 */
const extractDriversLicenseBirthday = (lines) => {
  console.log('üìÖ Extracting Driver\'s License Birthday');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Driver's license format: YYYY/MM/DD
    const datePattern = /(\d{4})[\/\-](\d{2})[\/\-](\d{2})/;
    const match = line.match(datePattern);
    
    if (match) {
      const year = match[1];
      const month = match[2];
      const day = match[3];
      
      // Skip if it's clearly an expiration date (year > 2025)
      if (parseInt(year) > 2025) {
        console.log('‚è≠Ô∏è Skipping expiration date:', match[0]);
        continue;
      }
      
      // Skip if preceded by "EXPIRATION"
      if (i > 0 && lines[i - 1].includes('EXPIRATION')) {
        continue;
      }
      
      const formattedDate = `${year}-${month}-${day}`;
      console.log('‚úÖ Found Birthday (direct pattern):', formattedDate);
      return formattedDate;
    }
  }
  
  return null;
};

/**
 * Driver's License Address Extraction - NEW FUNCTION
 */
const extractDriversLicenseAddress = (lines) => {
  console.log('üè† Extracting Driver\'s License Address');
  
  let addressLines = [];
  let foundAddressLabel = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Look for "Address" label
    if (line.includes('ADDRESS')) {
      foundAddressLabel = true;
      const addressPart = line.replace(/ADDRESS[:\s]*/i, '').trim();
      if (addressPart.length > 10 && !addressPart.includes('LICENSE')) {
        addressLines.push(addressPart);
      }
      continue;
    }
    
    // Collect address lines after label
    if (foundAddressLabel && addressLines.length < 2) {
      // Skip non-address lines
      if (line.includes('LICENSE') ||
          line.includes('EXPIRATION') ||
          line.includes('BLOOD') ||
          line.includes('EYES') ||
          line.includes('CONDITIONS') ||
          line.includes('SIGNATURE') ||
          line.includes('DL CODES') ||
          /^N\d{2}[-\s]?\d{2}[-\s]?\d{6}$/.test(line) || // License number
          /^\d{4}[\/\-]\d{2}[\/\-]\d{2}$/.test(line) || // Date
          /^[A-Z,]+$/.test(line) || // DL Codes like "A,A1,B"
          line.length < 10) {
        continue;
      }
      
      // Look for address indicators
      if (/\d+/.test(line) && ( // Has numbers
          line.includes('ST') ||
          line.includes('STREET') ||
          line.includes('BRGY') ||
          line.includes('BARANGAY') ||
          line.includes('CITY') ||
          line.includes('DISTRICT') ||
          line.includes('MANILA') ||
          line.includes('NCR') ||
          line.includes('TONDO') ||
          line.includes('BATO'))) {
        addressLines.push(line.trim());
      }
    }
  }
  
  if (addressLines.length > 0) {
    const fullAddress = addressLines.join(', ');
    console.log('‚úÖ Found Address:', fullAddress);
    return fullAddress;
  }
  
  return null;
};

/**
 * UMID Name Extraction - ENHANCED for Full Format
 */
const extractUMIDName = (lines) => {
  console.log('üìã UMID ID detected');
  console.log('üìÑ Lines:', lines);
  
  let surname = null;
  let givenName = null;
  let middleName = null;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
    
    // Skip header/system lines
    if (line.includes('UMID') || 
        line.includes('UNIFIED') ||
        line.includes('MULTI-PURPOSE') ||
        line.includes('IDENTIFICATION') ||
        line.includes('SSS') ||
        line.includes('GSIS') ||
        line.includes('PHILHEALTH') ||
        line.includes('HDMF') ||
        line.includes('CARD') ||
        line.includes('NUMBER') ||
        /^\d{4}-\d{7}-\d$/.test(line) || // UMID number format
        line.length < 2) {
      continue;
    }
    
    // Look for "SURNAME" label
    if (line.includes('SURNAME') || line.includes('LAST NAME') || line.includes('APELYIDO')) {
      if (nextLine && nextLine.length >= 2 && !nextLine.includes('/') && !nextLine.includes('GIVEN')) {
        surname = nextLine.trim();
        console.log('‚úÖ Found Surname:', surname);
      }
    }
    
    // Look for "GIVEN NAME" label
    if ((line.includes('GIVEN') && line.includes('NAME')) || line.includes('FIRST NAME')) {
      if (nextLine && nextLine.length >= 2 && !nextLine.includes('/') && !nextLine.includes('MIDDLE')) {
        givenName = nextLine.trim();
        console.log('‚úÖ Found Given Name:', givenName);
      }
    }
    
    // Look for "MIDDLE NAME" label
    if (line.includes('MIDDLE') && line.includes('NAME')) {
      if (nextLine && nextLine.length >= 2 && !nextLine.includes('/') && !nextLine.includes('DATE')) {
        middleName = nextLine.trim();
        console.log('‚úÖ Found Middle Name:', middleName);
      }
    }
  }
  
  // Construct full name: Given Name + Middle Name + Surname
  if (givenName && surname) {
    let fullName = givenName;
    if (middleName) {
      fullName += ' ' + middleName;
    }
    fullName += ' ' + surname;
    console.log('‚úÖ Constructed Full Name:', fullName);
    return fullName;
  }
  
  // Fallback: Look for comma-separated format "SURNAME, GIVEN MIDDLE"
  const nameWithCommaPattern = /^([A-Z\s]+),\s*([A-Z\s]+)$/;
  
  for (let line of lines) {
    if (line.includes('UMID') || 
        line.includes('UNIFIED') ||
        line.includes('SSS') ||
        line.includes('GSIS') ||
        /^\d{4}-\d{7}-\d$/.test(line)) {
      continue;
    }
    
    const match = line.match(nameWithCommaPattern);
    if (match) {
      const lastName = match[1].trim();
      const firstMiddle = match[2].trim();
      
      const lastWords = lastName.split(/\s+/);
      const firstWords = firstMiddle.split(/\s+/);
      
      if (lastWords.length >= 1 && lastWords.length <= 2 &&
          firstWords.length >= 2 && firstWords.length <= 4 &&
          lastName.length >= 2 && firstMiddle.length >= 4) {
        const fullName = `${firstMiddle} ${lastName}`;
        console.log('‚úÖ Extracted Full Name (comma format):', fullName);
        return fullName;
      }
    }
  }
  
  return null;
};

/**
 * UMID Sex Extraction - NEW FUNCTION
 */
const extractUMIDSex = (lines) => {
  console.log('üë§ Extracting UMID Sex');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
    
    // Look for "SEX" or "GENDER" label
    if (line.includes('SEX') || line.includes('GENDER')) {
      // Sex might be on the same line or next line
      
      // Check current line for M/F after label
      const sexMatch = line.match(/SEX[:\s]*([MF])/i) || line.match(/GENDER[:\s]*([MF])/i);
      if (sexMatch) {
        const sex = sexMatch[1].toUpperCase() === 'M' ? 'Male' : 'Female';
        console.log('‚úÖ Found Sex (same line):', sex);
        return sex;
      }
      
      // Check next line
      if (nextLine) {
        const nextSexMatch = nextLine.match(/^([MF])$/i) || nextLine.match(/^(MALE|FEMALE)$/i);
        if (nextSexMatch) {
          const sexValue = nextSexMatch[1].toUpperCase();
          const sex = (sexValue === 'M' || sexValue === 'MALE') ? 'Male' : 'Female';
          console.log('‚úÖ Found Sex (next line):', sex);
          return sex;
        }
      }
    }
    
    // Direct M/F pattern with context
    if (line.match(/SEX.*([MF])/i)) {
      const sexMatch = line.match(/([MF])/i);
      if (sexMatch) {
        const sex = sexMatch[1].toUpperCase() === 'M' ? 'Male' : 'Female';
        console.log('‚úÖ Found Sex (pattern):', sex);
        return sex;
      }
    }
  }
  
  return null;
};

/**
 * UMID Birthday Extraction - NEW FUNCTION
 */
const extractUMIDBirthday = (lines) => {
  console.log('üìÖ Extracting UMID Birthday');
  
  const monthNames = {
    'JANUARY': '01', 'FEBRUARY': '02', 'MARCH': '03', 'APRIL': '04',
    'MAY': '05', 'JUNE': '06', 'JULY': '07', 'AUGUST': '08',
    'SEPTEMBER': '09', 'OCTOBER': '10', 'NOVEMBER': '11', 'DECEMBER': '12',
    'JAN': '01', 'FEB': '02', 'MAR': '03', 'APR': '04',
    'JUN': '06', 'JUL': '07', 'AUG': '08', 'SEP': '09',
    'OCT': '10', 'NOV': '11', 'DEC': '12'
  };
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
    
    // Look for "DATE OF BIRTH" or "BIRTHDAY" label
    if ((line.includes('DATE') && line.includes('BIRTH')) || 
        line.includes('BIRTHDAY') ||
        line.includes('BIRTH DATE')) {
      
      // Birthday might be on same line or next line
      
      // Format: "MONTH DAY, YEAR" or "MONTH DAY YEAR"
      const datePattern1 = /([A-Z]+)\s+(\d{1,2}),?\s+(\d{4})/;
      const match1 = line.match(datePattern1) || (nextLine ? nextLine.match(datePattern1) : null);
      
      if (match1) {
        const month = monthNames[match1[1]];
        const day = match1[2].padStart(2, '0');
        const year = match1[3];
        
        if (month) {
          const formattedDate = `${year}-${month}-${day}`;
          console.log('‚úÖ Found Birthday (format 1):', formattedDate);
          return formattedDate;
        }
      }
      
      // Format: "DD/MM/YYYY" or "MM/DD/YYYY"
      const datePattern2 = /(\d{2})\/(\d{2})\/(\d{4})/;
      const match2 = line.match(datePattern2) || (nextLine ? nextLine.match(datePattern2) : null);
      
      if (match2) {
        // Assume MM/DD/YYYY format (common in Philippines)
        const month = match2[1].padStart(2, '0');
        const day = match2[2].padStart(2, '0');
        const year = match2[3];
        const formattedDate = `${year}-${month}-${day}`;
        console.log('‚úÖ Found Birthday (format 2):', formattedDate);
        return formattedDate;
      }
      
      // Format: "YYYY-MM-DD"
      const datePattern3 = /(\d{4})-(\d{2})-(\d{2})/;
      const match3 = line.match(datePattern3) || (nextLine ? nextLine.match(datePattern3) : null);
      
      if (match3) {
        console.log('‚úÖ Found Birthday (format 3):', match3[0]);
        return match3[0];
      }
    }
    
    // Direct date pattern search without label
    const directPattern = /([A-Z]+)\s+(\d{1,2}),?\s+(\d{4})/;
    const directMatch = line.match(directPattern);
    
    if (directMatch && monthNames[directMatch[1]]) {
      const month = monthNames[directMatch[1]];
      const day = directMatch[2].padStart(2, '0');
      const year = directMatch[3];
      const formattedDate = `${year}-${month}-${day}`;
      console.log('‚úÖ Found Birthday (direct pattern):', formattedDate);
      return formattedDate;
    }
  }
  
  return null;
};

/**
 * UMID Address Extraction - NEW FUNCTION
 */
const extractUMIDAddress = (lines) => {
  console.log('üè† Extracting UMID Address');
  
  let addressLines = [];
  let foundAddressLabel = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Look for "ADDRESS" label
    if (line.includes('ADDRESS') || line.includes('RESIDENCE')) {
      foundAddressLabel = true;
      
      // Address might be on same line after label
      const addressPart = line.replace(/ADDRESS[:\s]*/i, '').replace(/RESIDENCE[:\s]*/i, '').trim();
      if (addressPart.length > 5 && !addressPart.includes('NUMBER')) {
        addressLines.push(addressPart);
      }
      continue;
    }
    
    // Collect address lines after the label
    if (foundAddressLabel && addressLines.length < 3) {
      // Skip lines that are clearly not address
      if (line.includes('DATE') ||
          line.includes('BIRTH') ||
          line.includes('SEX') ||
          line.includes('UMID') ||
          line.includes('NUMBER') ||
          /^\d{4}-\d{7}-\d$/.test(line) || // UMID ID number
          line.length < 5) {
        continue;
      }
      
      // Look for address patterns
      if (/\d/.test(line) || // Contains numbers
          line.includes('ST.') ||
          line.includes('STREET') ||
          line.includes('BRGY') ||
          line.includes('BARANGAY') ||
          line.includes('CITY') ||
          line.includes('PROVINCE') ||
          line.includes('ZONE') ||
          line.includes('AVENUE') ||
          line.includes('ROAD')) {
        addressLines.push(line.trim());
      }
    }
    
    // Alternative: Look for address-like lines without label
    if (!foundAddressLabel && addressLines.length === 0) {
      if ((line.includes('BRGY') || line.includes('BARANGAY')) && /\d/.test(line)) {
        addressLines.push(line.trim());
        foundAddressLabel = true;
      }
    }
  }
  
  if (addressLines.length > 0) {
    const fullAddress = addressLines.join(', ');
    console.log('‚úÖ Found Address:', fullAddress);
    return fullAddress;
  }
  
  return null;
};

/**
 * PhilSys Name Extraction - IMPROVED VERSION
 * Format: Stacked vertically - Apelyido/Last Name, Mga Pangalan/Given Names, Gitnang Apelyido/Middle Name
 */
const extractPhilsysName = (lines) => {
  console.log('üìã PhilSys ID detected');
  console.log('üìÑ All Lines:', lines);
  
  let lastName = null;
  let givenNames = null;
  let middleName = null;
  
  // Strategy 1: Look for labeled sections
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
    const nextNextLine = i + 2 < lines.length ? lines[i + 2] : '';
    
    // Skip header lines
    if (line.includes('PHILSYS') || 
        line.includes('PHILIPPINE') ||
        line.includes('IDENTIFICATION') ||
        line.includes('SYSTEM') ||
        line.includes('REPUBLIKA') ||
        line.includes('PAMBANSANG') ||
        line.includes('PAGKAKAKILANLAN') ||
        line.includes('REPUBLIC') ||
        /^\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}$/.test(line.replace(/\s/g, ''))) {
      continue;
    }
    
    // Look for Last Name label variations (APELYIDO / LAST NAME)
    if (line.includes('APELYIDO') || line.includes('APELLYIDO') || 
        (line.includes('LAST') && line.includes('NAME'))) {
      
      // Check if value is on the same line (after the label)
      const afterLabel = line
        .replace(/APELYIDO|APELLYIDO|LAST\s*NAME|MGA|[\/\|\:]/gi, '')
        .trim();
      
      if (afterLabel.length >= 2 && /^[A-Z][A-Z\s\-']+$/.test(afterLabel)) {
        lastName = afterLabel;
        console.log('‚úÖ Found Last Name (same line):', lastName);
      } else if (nextLine && nextLine.length >= 2) {
        // Check next line - should be just a name, not a label
        const cleanNext = nextLine.replace(/[\/\|\:]/g, '').trim();
        if (!cleanNext.includes('PANGALAN') && 
            !cleanNext.includes('GIVEN') &&
            !cleanNext.includes('APELYIDO') &&
            /^[A-Z][A-Z\s\-']+$/.test(cleanNext) &&
            cleanNext.length <= 30) {
          lastName = cleanNext;
          console.log('‚úÖ Found Last Name (next line):', lastName);
        }
      }
    }
    
    // Look for Given Names label variations (MGA PANGALAN / GIVEN NAMES)
    if ((line.includes('PANGALAN') && !line.includes('GITNANG')) || 
        (line.includes('GIVEN') && line.includes('NAME'))) {
      
      // Check if value is on the same line
      const afterLabel = line
        .replace(/MGA\s*PANGALAN|PANGALAN|GIVEN\s*NAMES?|[\/\|\:]/gi, '')
        .trim();
      
      if (afterLabel.length >= 2 && /^[A-Z][A-Z\s\-']+$/.test(afterLabel)) {
        givenNames = afterLabel;
        console.log('‚úÖ Found Given Names (same line):', givenNames);
      } else if (nextLine && nextLine.length >= 2) {
        const cleanNext = nextLine.replace(/[\/\|\:]/g, '').trim();
        if (!cleanNext.includes('GITNANG') && 
            !cleanNext.includes('MIDDLE') &&
            !cleanNext.includes('APELYIDO') &&
            /^[A-Z][A-Z\s\-']+$/.test(cleanNext) &&
            cleanNext.length <= 40) {
          givenNames = cleanNext;
          console.log('‚úÖ Found Given Names (next line):', givenNames);
        }
      }
    }
    
    // Look for Middle Name label variations (GITNANG APELYIDO / MIDDLE NAME)
    if ((line.includes('GITNANG') && (line.includes('APELYIDO') || line.includes('APELLYIDO'))) || 
        (line.includes('MIDDLE') && line.includes('NAME'))) {
      
      // Check if value is on the same line
      const afterLabel = line
        .replace(/GITNANG\s*APELYIDO|GITNANG\s*APELLYIDO|MIDDLE\s*NAME|[\/\|\:]/gi, '')
        .trim();
      
      if (afterLabel.length >= 2 && /^[A-Z][A-Z\s\-']+$/.test(afterLabel)) {
        middleName = afterLabel;
        console.log('‚úÖ Found Middle Name (same line):', middleName);
      } else if (nextLine && nextLine.length >= 2) {
        const cleanNext = nextLine.replace(/[\/\|\:]/g, '').trim();
        if (!cleanNext.includes('PETSA') && 
            !cleanNext.includes('DATE') &&
            !cleanNext.includes('BIRTH') &&
            !cleanNext.includes('KAPANGANAKAN') &&
            /^[A-Z][A-Z\s\-']+$/.test(cleanNext) &&
            cleanNext.length <= 30) {
          middleName = cleanNext;
          console.log('‚úÖ Found Middle Name (next line):', middleName);
        }
      }
    }
  }
  
  // Construct full name: Given Names + Middle Name + Last Name
  if (givenNames && lastName) {
    let fullName = givenNames;
    if (middleName) {
      fullName += ' ' + middleName;
    }
    fullName += ' ' + lastName;
    console.log('‚úÖ Constructed Full Name:', fullName);
    return fullName;
  }
  
  // Strategy 2: Pattern-based extraction for OCR variations
  // Look for consecutive name-like lines (PhilSys has stacked names)
  let nameCandidates = [];
  let skipUntilIndex = -1;
  
  for (let i = 0; i < lines.length; i++) {
    if (i <= skipUntilIndex) continue;
    
    const line = lines[i];
    
    // Skip obvious non-name lines
    if (line.includes('PHILSYS') || 
        line.includes('PHILIPPINE') ||
        line.includes('REPUBLIKA') ||
        line.includes('REPUBLIC') ||
        line.includes('PAMBANSANG') ||
        line.includes('IDENTIFICATION') ||
        line.includes('PETSA') ||
        line.includes('DATE') ||
        line.includes('BIRTH') ||
        line.includes('KAPANGANAKAN') ||
        line.includes('TIRAHAN') ||
        line.includes('ADDRESS') ||
        line.includes('APELYIDO') ||
        line.includes('APELLYIDO') ||
        line.includes('PANGALAN') ||
        line.includes('GITNANG') ||
        line.includes('LAST NAME') ||
        line.includes('GIVEN') ||
        line.includes('MIDDLE') ||
        line.includes('/') ||
        /^\d{4}[-\s]?\d{4}[-\s]?\d{4}/.test(line) ||
        /[A-Z]+\s+\d{1,2},?\s+\d{4}/.test(line) ||
        line.length < 2 ||
        line.length > 35) {
      continue;
    }
    
    // Check if line looks like a name (letters only, with optional hyphen/apostrophe)
    const cleanLine = line.replace(/[\/\|\:\-\']/g, ' ').replace(/\s+/g, ' ').trim();
    if (/^[A-Z][A-Z\s]+$/.test(cleanLine) && 
        cleanLine.split(/\s+/).length <= 4 &&
        cleanLine.length >= 2) {
      nameCandidates.push({
        line: cleanLine,
        index: i
      });
    }
  }
  
  console.log('üìù Name candidates:', nameCandidates);
  
  // If we have 2-3 consecutive name candidates, treat as: Last, Given, Middle
  if (nameCandidates.length >= 2) {
    for (let i = 0; i < nameCandidates.length - 1; i++) {
      const current = nameCandidates[i];
      const next = nameCandidates[i + 1];
      
      // If candidates are close together (within 3 lines), treat as name parts
      if (next.index - current.index <= 3) {
        // PhilSys order: Last Name, Given Names, [Middle Name]
        lastName = current.line;
        givenNames = next.line;
        
        // Check for middle name
        if (i + 2 < nameCandidates.length) {
          const third = nameCandidates[i + 2];
          if (third.index - next.index <= 3) {
            middleName = third.line;
          }
        }
        
        if (givenNames && lastName) {
          let fullName = givenNames;
          if (middleName) {
            fullName += ' ' + middleName;
          }
          fullName += ' ' + lastName;
          console.log('‚úÖ Constructed Full Name (from candidates):', fullName);
          return fullName;
        }
      }
    }
  }
  
  // Strategy 3: Fallback - comma-separated format
  const nameWithCommaPattern = /^([A-Z][A-Z\s\-']+),\s*([A-Z][A-Z\s\-']+)$/;
  
  for (let line of lines) {
    if (line.includes('PHILSYS') || 
        line.includes('PHILIPPINE') ||
        line.includes('IDENTIFICATION') ||
        /^\d{4}[-\s]?\d{4}/.test(line)) {
      continue;
    }
    
    const match = line.match(nameWithCommaPattern);
    if (match) {
      const part1 = match[1].trim();
      const part2 = match[2].trim();
      
      if (part1.length >= 2 && part2.length >= 2) {
        // Assume: SURNAME, GIVEN MIDDLE
        const fullName = `${part2} ${part1}`;
        console.log('‚úÖ Extracted Full Name (comma format):', fullName);
        return fullName;
      }
    }
  }
  
  console.log('‚ùå No valid PhilSys name found');
  return null;
};

/**
 * PhilSys Birthday Extraction - IMPROVED VERSION
 * Format: "Petsa ng Kapanganakan / Date of Birth" followed by "APRIL 15, 1978"
 */
const extractPhilsysBirthday = (lines) => {
  console.log('üìÖ Extracting PhilSys Birthday');
  
  const monthNames = {
    'JANUARY': '01', 'FEBRUARY': '02', 'MARCH': '03', 'APRIL': '04',
    'MAY': '05', 'JUNE': '06', 'JULY': '07', 'AUGUST': '08',
    'SEPTEMBER': '09', 'OCTOBER': '10', 'NOVEMBER': '11', 'DECEMBER': '12'
  };
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
    const nextNextLine = i + 2 < lines.length ? lines[i + 2] : '';
    
    // Look for date of birth label
    const isDateLabel = 
      (line.includes('PETSA') && (line.includes('KAPANGANAKAN') || line.includes('BIRTH'))) ||
      (line.includes('DATE') && line.includes('BIRTH')) ||
      line.includes('KAPANGANAKAN');
    
    if (isDateLabel) {
      // Check current line for date value after the label
      for (const [monthName, monthNum] of Object.entries(monthNames)) {
        const pattern = new RegExp(`${monthName}\\s+(\\d{1,2}),?\\s+(\\d{4})`, 'i');
        const match = line.match(pattern);
        if (match) {
          const day = match[1].padStart(2, '0');
          const year = match[2];
          const formattedDate = `${year}-${monthNum}-${day}`;
          console.log('‚úÖ Found Birthday (same line):', formattedDate);
          return formattedDate;
        }
      }
      
      // Check next line
      if (nextLine) {
        for (const [monthName, monthNum] of Object.entries(monthNames)) {
          const pattern = new RegExp(`${monthName}\\s+(\\d{1,2}),?\\s+(\\d{4})`, 'i');
          const match = nextLine.match(pattern);
          if (match) {
            const day = match[1].padStart(2, '0');
            const year = match[2];
            const formattedDate = `${year}-${monthNum}-${day}`;
            console.log('‚úÖ Found Birthday (next line):', formattedDate);
            return formattedDate;
          }
        }
        
        // Numeric format: YYYY-MM-DD or MM/DD/YYYY or DD/MM/YYYY
        const numericPattern1 = /(\d{4})[-\/](\d{2})[-\/](\d{2})/;
        const numericPattern2 = /(\d{2})[-\/](\d{2})[-\/](\d{4})/;
        
        let numMatch = nextLine.match(numericPattern1);
        if (numMatch) {
          console.log('‚úÖ Found Birthday (YYYY-MM-DD):', `${numMatch[1]}-${numMatch[2]}-${numMatch[3]}`);
          return `${numMatch[1]}-${numMatch[2]}-${numMatch[3]}`;
        }
        
        numMatch = nextLine.match(numericPattern2);
        if (numMatch) {
          // Assume MM/DD/YYYY for Philippines
          console.log('‚úÖ Found Birthday (MM/DD/YYYY):', `${numMatch[3]}-${numMatch[1]}-${numMatch[2]}`);
          return `${numMatch[3]}-${numMatch[1]}-${numMatch[2]}`;
        }
      }
      
      // Check next next line (sometimes there's spacing)
      if (nextNextLine) {
        for (const [monthName, monthNum] of Object.entries(monthNames)) {
          const pattern = new RegExp(`${monthName}\\s+(\\d{1,2}),?\\s+(\\d{4})`, 'i');
          const match = nextNextLine.match(pattern);
          if (match) {
            const day = match[1].padStart(2, '0');
            const year = match[2];
            const formattedDate = `${year}-${monthNum}-${day}`;
            console.log('‚úÖ Found Birthday (next next line):', formattedDate);
            return formattedDate;
          }
        }
      }
    }
  }
  
  // Direct search for date pattern anywhere (fallback)
  for (let line of lines) {
    // Skip non-birthday contexts
    if (line.includes('VALID') || line.includes('EXPIR') || 
        line.includes('TIRAHAN') || line.includes('ADDRESS')) {
      continue;
    }
    
    for (const [monthName, monthNum] of Object.entries(monthNames)) {
      const pattern = new RegExp(`${monthName}\\s+(\\d{1,2}),?\\s+(\\d{4})`, 'i');
      const match = line.match(pattern);
      if (match) {
        const day = match[1].padStart(2, '0');
        const year = match[2];
        
        // Validate year is reasonable for a birthday (1900-2023)
        const yearInt = parseInt(year);
        if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
          const formattedDate = `${year}-${monthNum}-${day}`;
          console.log('‚úÖ Found Birthday (direct search):', formattedDate);
          return formattedDate;
        }
      }
    }
  }
  
  console.log('‚ùå No PhilSys birthday found');
  return null;
};

/**
 * PhilSys Address Extraction - IMPROVED VERSION
 * Format: "Tirahan / Address" followed by Street, Barangay, City (may span multiple lines)
 */
const extractPhilsysAddress = (lines) => {
  console.log('üè† Extracting PhilSys Address');
  
  let addressParts = [];
  let foundAddressLabel = false;
  let addressStartIndex = -1;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Look for address label
    const isAddressLabel = 
      (line.includes('TIRAHAN') && line.includes('ADDRESS')) ||
      line.includes('TIRAHAN/ADDRESS') ||
      line === 'TIRAHAN' || 
      (line === 'ADDRESS' && !line.includes('PERMANENT'));
    
    if (isAddressLabel) {
      foundAddressLabel = true;
      addressStartIndex = i;
      
      // Check if address starts on the same line
      const afterLabel = line
        .replace(/TIRAHAN|ADDRESS|[\/\|\:]/gi, '')
        .trim();
      
      if (afterLabel.length > 3 && 
          !afterLabel.includes('PETSA') && 
          !afterLabel.includes('DATE') &&
          !afterLabel.includes('BIRTH')) {
        addressParts.push(afterLabel);
      }
      continue;
    }
    
    // Collect address lines after the label (up to 3 lines)
    if (foundAddressLabel && addressParts.length < 3 && i > addressStartIndex) {
      // Stop conditions
      if (line.includes('PETSA') || 
          line.includes('DATE') ||
          line.includes('BIRTH') ||
          line.includes('KAPANGANAKAN') ||
          line.includes('APELYIDO') ||
          line.includes('PANGALAN') ||
          line.includes('PHILSYS') ||
          /^\d{4}[-\s]?\d{4}[-\s]?\d{4}/.test(line) ||
          /[A-Z]+\s+\d{1,2},?\s+\d{4}/.test(line) ||
          line.length < 3) {
        break;
      }
      
      // Skip label lines
      if (line.includes('GITNANG') || 
          line.includes('MIDDLE') ||
          line.includes('LAST NAME') ||
          line.includes('GIVEN')) {
        continue;
      }
      
      // Address-like patterns
      const hasAddressIndicators = 
        /\d/.test(line) ||
        line.includes('ST') ||
        line.includes('STREET') ||
        line.includes('BRGY') ||
        line.includes('BARANGAY') ||
        line.includes('CITY') ||
        line.includes('ZONE') ||
        line.includes('PUROK') ||
        line.includes('AVENUE') ||
        line.includes('AVE') ||
        line.includes('ROAD') ||
        line.includes('RD') ||
        line.includes('BLVD') ||
        line.includes('BOULEVARD') ||
        line.includes('DRIVE') ||
        line.includes('SUBDIVISION') ||
        line.includes('SUBD') ||
        line.includes('VILLAGE') ||
        line.includes('VILL') ||
        line.includes('COMPOUND') ||
        line.includes('BLDG') ||
        line.includes('BUILDING') ||
        line.includes('PHASE') ||
        line.includes('BLOCK') ||
        line.includes('LOT') ||
        line.includes('FLOOR');
      
      if (hasAddressIndicators || 
          (addressParts.length > 0 && line.length >= 3 && /^[A-Z0-9]/.test(line))) {
        addressParts.push(line.trim());
      }
    }
  }
  
  // Alternative: Look for address-like patterns without label
  if (addressParts.length === 0) {
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // Skip header/label/name/date lines
      if (line.includes('PHILSYS') || 
          line.includes('REPUBLIKA') ||
          line.includes('REPUBLIC') ||
          line.includes('APELYIDO') ||
          line.includes('PANGALAN') ||
          line.includes('GITNANG') ||
          line.includes('PETSA') ||
          line.includes('DATE') ||
          line.includes('BIRTH') ||
          line.includes('TIRAHAN') ||
          line.includes('ADDRESS') ||
          /^\d{4}[-\s]?\d{4}[-\s]?\d{4}/.test(line) ||
          /^[A-Z]+\s+\d{1,2},?\s+\d{4}$/.test(line)) {
        continue;
      }
      
      // Look for street address pattern (number + text, or BRGY/BARANGAY)
      const isStreetAddress = 
        /^\d+[-\s]?[A-Z]?\s+[A-Z]/.test(line) ||
        /^[A-Z]+\s+\d+/.test(line) ||
        line.includes('BRGY') ||
        line.includes('BARANGAY');
      
      if (isStreetAddress) {
        addressParts.push(line.trim());
        
        // Get next 1-2 lines as continuation
        for (let j = i + 1; j < Math.min(i + 3, lines.length); j++) {
          const nextLine = lines[j];
          if (nextLine.includes('PETSA') || 
              nextLine.includes('DATE') ||
              nextLine.includes('BIRTH') ||
              nextLine.includes('PHILSYS') ||
              /^\d{4}[-\s]?\d{4}/.test(nextLine) ||
              /^[A-Z]+\s+\d{1,2},?\s+\d{4}$/.test(nextLine) ||
              nextLine.length < 3) {
            break;
          }
          
          // Check if it looks like address continuation
          if (/[A-Z0-9]/.test(nextLine) && nextLine.length >= 3) {
            addressParts.push(nextLine.trim());
          }
        }
        break;
      }
    }
  }
  
  if (addressParts.length > 0) {
    const fullAddress = addressParts.join(', ');
    console.log('‚úÖ Found Address:', fullAddress);
    return fullAddress;
  }
  
  console.log('‚ùå No PhilSys address found');
  return null;
};

const extractPagIbigName = (lines) => {
  console.log('üìã PAG-IBIG ID detected');
  console.log('üìÑ Lines:', lines);
  
  // Strategy: Find the line immediately BEFORE "MID NO" or "MID No."
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : '';
    
    // Check if NEXT line contains "MID" and a number pattern
    const isMIDLine = /MID\s*NO\.?/i.test(nextLine) || /\d{4}-\d{4}-\d{4}/.test(nextLine);
    
    if (isMIDLine && line) {
      // Skip if current line is a header/label
      if (line.includes('PAG-IBIG') || 
          line.includes('HDMF') ||
          line.includes('LOYALTY') ||
          line.includes('CARD') ||
          line.includes('PLUS') ||
          line.length < 3) {
        continue;
      }
      
      // Validate: should contain mostly letters and spaces
      // Allow periods for middle initials (e.g., "M.")
      const words = line.split(/\s+/);
      const hasValidFormat = words.length >= 2 && words.length <= 5;
      
      // Check if mostly alphabetic (allow periods and hyphens for names)
      const letterCount = (line.match(/[A-Z]/g) || []).length;
      const isNameLike = letterCount / line.length >= 0.7;
      
      if (hasValidFormat && isNameLike) {
        console.log('‚úÖ Found PAG-IBIG Name:', line);
        return line;
      }
    }
  }
  
  console.log('‚ùå No PAG-IBIG name found');
  return null;
};

/**
 * Postal ID Name Extraction - ENHANCED
 */
const extractPostalIDName = (lines) => {
  console.log('üìã Postal ID detected');
  console.log('üìÑ Lines:', lines);
  
  // Postal ID format: "FIRST NAME, MIDDLE NAME, SURNAME, SUFFIX" on one line
  // Or: "SURNAME, FIRST NAME MIDDLE NAME" format
  
  let fullName = null;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Skip header/label lines
    if (line.includes('POSTAL') || 
        line.includes('REPUBLIC') ||
        line.includes('PHILIPPINES') ||
        line.includes('CORPORATION') ||
        line.includes('IDENTITY') ||
        line.includes('CARD') ||
        line.includes('PRN') ||
        line.includes('HOLDER') ||
        line.includes('SIGNATURE') ||
        line.includes('POSTMASTER') ||
        line.includes('PREMIUM') ||
        /^[A-Z]{3}\d{6,10}$/.test(line) || // Postal ID number format
        /^PRN\s+[A-Z0-9]+$/.test(line) || // PRN number
        /^\d{2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{2}$/.test(line) || // Date format
        line.includes('Date of Birth') ||
        line.includes('Address') ||
        line.includes('Nationality') ||
        line.includes('Valid Until') ||
        line.includes('Post Office') ||
        line.length < 5) {
      continue;
    }
    
    // Look for comma-separated name format
    if (line.includes(',')) {
      // Format 1: "SURNAME, FIRST MIDDLE" or "FIRST, MIDDLE, SURNAME"
      const parts = line.split(',').map(p => p.trim());
      
      if (parts.length >= 2) {
        // Check if this looks like a valid name (at least 2 words total)
        const totalWords = parts.join(' ').split(/\s+/).length;
        
        if (totalWords >= 2 && totalWords <= 6) {
          // Assume format: "SURNAME, FIRST MIDDLE"
          const surname = parts[0].trim();
          const firstMiddle = parts.slice(1).join(' ').trim();
          
          // Validate: surname should be 1-2 words, first+middle should be 1-4 words
          const surnameWords = surname.split(/\s+/);
          const firstMiddleWords = firstMiddle.split(/\s+/);
          
          if (surnameWords.length >= 1 && surnameWords.length <= 2 &&
              firstMiddleWords.length >= 1 && firstMiddleWords.length <= 4 &&
              surname.length >= 2 && firstMiddle.length >= 2) {
            
            fullName = `${firstMiddle} ${surname}`;
            console.log('‚úÖ Extracted Full Name (comma format):', fullName);
            return fullName;
          }
        }
      }
    }
  }
  
  // Fallback: Look for line with 2-5 words that looks like a name
  for (let line of lines) {
    if (line.includes('POSTAL') || 
        line.includes('REPUBLIC') ||
        line.includes('PHILIPPINES') ||
        line.includes('CORPORATION') ||
        line.includes('PRN') ||
        /^\d/.test(line) || // Starts with number (likely address)
        line.length < 5) {
      continue;
    }
    
    const words = line.split(/\s+/);
    if (words.length >= 2 && words.length <= 5) {
      // Check if all words look like name parts (mostly letters)
      const looksLikeName = words.every(word => 
        /^[A-Z][A-Z\s\-'\.]*$/i.test(word) && word.length >= 2
      );
      
      if (looksLikeName) {
        fullName = line;
        console.log('‚úÖ Extracted Full Name (fallback):', fullName);
        return fullName;
      }
    }
  }
  
  return null;
};

/**
 * Postal ID Birthday Extraction - NEW FUNCTION
 */
const extractPostalIDBirthday = (lines) => {
  console.log('üìÖ Extracting Postal ID Birthday');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Look for "Date of Birth" label
    if ((line.includes('DATE') && line.includes('BIRTH')) ||
        line.includes('Date of Birth')) {
      
      // Birthday might be on the same line or next line
      // Format: "15 Apr 78" or "15 APR 1978"
      
      // Check current line first
      const dateMatch = line.match(/(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{2,4})/i);
      if (dateMatch) {
        return formatPostalDate(dateMatch[1], dateMatch[2], dateMatch[3]);
      }
      
      // Check next line
      if (i + 1 < lines.length) {
        const nextLine = lines[i + 1];
        const nextDateMatch = nextLine.match(/(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{2,4})/i);
        if (nextDateMatch) {
          return formatPostalDate(nextDateMatch[1], nextDateMatch[2], nextDateMatch[3]);
        }
      }
    }
    
    // Direct date pattern search (without label)
    const directMatch = line.match(/(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{2,4})/i);
    if (directMatch && !line.includes('Valid Until')) {
      return formatPostalDate(directMatch[1], directMatch[2], directMatch[3]);
    }
  }
  
  return null;
};

/**
 * Postal ID Address Extraction - NEW FUNCTION
 */
const extractPostalIDAddress = (lines) => {
  console.log('üè† Extracting Postal ID Address');
  
  let addressLines = [];
  let foundAddressLabel = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Look for "Address" label
    if (line.includes('Address')) {
      foundAddressLabel = true;
      
      // Address might be on the same line after "Address"
      const addressPart = line.replace(/Address\s*/i, '').trim();
      if (addressPart.length > 5) {
        addressLines.push(addressPart);
      }
      continue;
    }
    
    // Collect address lines after the label
    if (foundAddressLabel && addressLines.length < 2) {
      // Skip lines that are clearly not address
      if (line.includes('Date of Birth') ||
          line.includes('Nationality') ||
          line.includes('Valid Until') ||
          line.includes('Post Office') ||
          line.includes('POSTAL') ||
          line.includes('PRN') ||
          /^[A-Z]{3}\d{6,10}$/.test(line) || // Postal ID number
          line.length < 5) {
        continue;
      }
      
      // Look for address patterns (contains numbers, street names, etc.)
      if (/\d/.test(line) || // Contains numbers
          line.includes('ST.') ||
          line.includes('STREET') ||
          line.includes('BRGY') ||
          line.includes('ZONE') ||
          line.includes('NCR') ||
          line.includes('MANILA') ||
          line.includes('CITY') ||
          line.includes('PROVINCE')) {
        addressLines.push(line.trim());
      }
    }
    
    // Alternative: Look for address-like lines without label
    if (!foundAddressLabel && addressLines.length === 0) {
      // Address typically has numbers and street/location keywords
      if (/\d+-[A-Z]/.test(line) || // e.g., "1503-D FABIE ST."
          (line.includes('ST.') && /\d/.test(line)) ||
          (line.includes('BRGY') && /\d/.test(line))) {
        addressLines.push(line.trim());
        foundAddressLabel = true;
      }
    }
  }
  
  if (addressLines.length > 0) {
    const fullAddress = addressLines.join(', ');
    console.log('‚úÖ Found Address:', fullAddress);
    return fullAddress;
  }
  
  return null;
};

/**
 * Helper: Format Postal ID date to YYYY-MM-DD
 */
const formatPostalDate = (day, month, year) => {
  const monthMap = {
    'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
    'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',
    'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12',
    'JAN': '01', 'FEB': '02', 'MAR': '03', 'APR': '04',
    'MAY': '05', 'JUN': '06', 'JUL': '07', 'AUG': '08',
    'SEP': '09', 'OCT': '10', 'NOV': '11', 'DEC': '12'
  };
  
  const monthNum = monthMap[month] || '01';
  const dayNum = day.padStart(2, '0');
  
  // Handle 2-digit year (e.g., "78" -> "1978")
  let yearNum = year;
  if (year.length === 2) {
    const yearInt = parseInt(year);
    yearNum = yearInt > 50 ? `19${year}` : `20${year}`;
  }
  
  const formattedDate = `${yearNum}-${monthNum}-${dayNum}`;
  console.log('‚úÖ Formatted Birthday:', formattedDate);
  return formattedDate;
};

/**
 * Enhanced ID extraction based on user-selected ID type
 */
export const extractNameByIDType = (text, idType) => {
  const lines = text.split('\n').map(line => line.trim().toUpperCase()).filter(line => line.length > 0);
  
  console.log('üîç Processing lines for ID type:', idType);
  console.log('üìÑ Lines:', lines);

  switch(idType) {
    case 'philhealth':
      return extractPhilHealthName(lines);
    case 'drivers_license':
      return extractDrivingLicenseName(lines);
    case 'umid':
      return extractUMIDName(lines);
    case 'philsys':
      return extractPhilsysName(lines);
    case 'pagibig':
      return extractPagIbigName(lines);
    case 'postal':
      return extractPostalIDName(lines);
    default:
      console.log('‚ùå Unknown ID type:', idType);
      return null;
  }
};

/**
 * Extract ID number based on ID type
 */
export const extractIDNumber = (text, idType) => {
  console.log('üîç Extracting ID number for type:', idType);
  
  const patterns = {
    philhealth: /\b\d{2}[-\s]?\d{9}[-\s]?\d\b/,
    umid: /\b\d{4}[-\s]?\d{7}[-\s]?\d\b/,
    drivers_license: /\bN\d{2}[-\s]?\d{2}[-\s]?\d{6}\b/,
    philsys: /\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/,
    pagibig: /\b\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/,
    postal: /\b[A-Z]{3}\s*\d{12}\s*P\b/
  };
  
  const pattern = patterns[idType];
  if (!pattern) {
    console.log('‚ùå No pattern found for ID type:', idType);
    return null;
  }
  
  // Clean up the text - remove excessive spaces and normalize
  const cleanedText = text.replace(/\s+/g, ' ').trim();
  
  const match = cleanedText.match(pattern);
  if (match) {
    console.log('‚úÖ Found ID number:', match[0]);
    return match[0].replace(/\s/g, '-'); // Normalize separators to hyphens
  }
  
  console.log('‚ùå No ID number found');
  return null;
};

/**
 * Extract name from ID (legacy)
 */
export const extractNameFromID = (text, idType) => {
  return extractNameByIDType(text, idType);
};

/**
 * Main OCR processing with ID type specification
 */
export const processIDWithOCREnhanced = async (imageData, idType, retryCount = 0) => {
  try {
    console.log(`üîç OCR Attempt ${retryCount + 1} for ID type: ${idType}`);
    
    if (!idType) {
      return {
        success: false,
        name: null,
        sex: null,
        birthday: null,
        address: null,
        idNumber: null,
        rawText: '',
        confidence: 0,
        message: 'Please select an ID type before scanning'
      };
    }
    
    // Run OCR
    const { data: { text, confidence } } = await Tesseract.recognize(
      imageData, 
      OCR_CONFIG.lang,
      {
        logger: m => {
          if (m.status === 'recognizing text') {
            console.log(`Progress:`, Math.round(m.progress * 100) + '%');
          }
        },
        ...OCR_CONFIG
      }
    );
    
    console.log(`üìÑ Raw Text:`, text);
    console.log(`üìä Confidence:`, confidence);
    
    // Extract name
    const extractedName = extractNameByIDType(text, idType);
    
    // Extract ID number
    const extractedIDNumber = extractIDNumber(text, idType);
    
    // Extract additional fields based on ID type
    let extractedSex = null;
    let extractedBirthday = null;
    let extractedAddress = null;
    
    const lines = text.split('\n').map(line => line.trim().toUpperCase()).filter(line => line.length > 0);
    
    if (idType === 'philhealth') {
      extractedSex = extractPhilHealthSex(lines);
      extractedBirthday = extractPhilHealthBirthday(lines);
      extractedAddress = extractPhilHealthAddress(lines);
    } else if (idType === 'drivers_license') {
      extractedSex = extractDriversLicenseSex(lines);
      extractedBirthday = extractDriversLicenseBirthday(lines);
      extractedAddress = extractDriversLicenseAddress(lines);
    } else if (idType === 'philsys') {
      extractedBirthday = extractPhilsysBirthday(lines);
      extractedAddress = extractPhilsysAddress(lines);
    } else if (idType === 'postal') {
      extractedBirthday = extractPostalIDBirthday(lines);
      extractedAddress = extractPostalIDAddress(lines);
    } else if (idType === 'umid') {
      extractedSex = extractUMIDSex(lines);
      extractedBirthday = extractUMIDBirthday(lines);
      extractedAddress = extractUMIDAddress(lines);
    }
    
    if (extractedName) {
      return {
        success: true,
        name: extractedName,
        sex: extractedSex,
        birthday: extractedBirthday,
        address: extractedAddress,
        idNumber: extractedIDNumber,
        idType: idType,
        rawText: text,
        confidence: confidence,
        message: `${idType.toUpperCase()} data extracted successfully!`
      };
    }
    
    return {
      success: false,
      name: null,
      sex: null,
      birthday: null,
      address: null,
      idNumber: extractedIDNumber,
      idType: idType,
      rawText: text,
      confidence: confidence,
      message: `Could not extract name from ${idType.toUpperCase()}. Please verify the ID is clearly visible or enter manually.`
    };
    
  } catch (error) {
    console.error('‚ùå OCR Error:', error);
    return {
      success: false,
      name: null,
      sex: null,
      birthday: null,
      address: null,
      idNumber: null,
      rawText: '',
      confidence: 0,
      message: 'OCR processing failed. Please try again.',
      error: error.message
    };
  }
};

// Main export
export const processIDWithOCR = processIDWithOCREnhanced;

// Default export - MODIFIED to include PhilHealth functions
export default {
  processIDWithOCR,
  processIDWithOCREnhanced,
  extractNameFromID,
  extractNameByIDType,
  extractIDNumber,
  extractDrivingLicenseName,
  extractDriversLicenseSex,
  extractDriversLicenseBirthday,
  extractDriversLicenseAddress,
  extractPhilHealthSex,
  extractPhilHealthBirthday,
  extractPhilHealthAddress,
  extractPhilsysBirthday,
  extractPhilsysAddress,
  extractPhilHealthIDNumber,
  extractPostalIDBirthday,
  extractPostalIDAddress,
  extractUMIDSex,
  extractUMIDBirthday,
  extractUMIDAddress,
  preprocessingTechniques,
  isCameraAvailable,
  initializeCamera,
  cleanupCamera,
  captureImageFromVideo,
  filterNoiseLines,
  detectIDInFrame,
  cropAndPreprocessID,
  startAutoCapture
};/**
 * PhilHealth Name Extraction - REVISED VERSION
 * Input Format: "LEJARDE, JERELYN MANGADLAO" (SURNAME, FIRSTNAME MIDDLENAME)
 * Output Format: "JERELYN MANGADLAO LEJARDE" (FIRSTNAME MIDDLENAME SURNAME)
 */
const extractPhilHealthName = (lines) => {
  console.log('üìã PhilHealth ID detected');
  console.log('üìÑ All Lines:', lines);
  
  const cleanLines = filterNoiseLines(lines);
  console.log('üìÑ Clean Lines:', cleanLines);
  
  // PhilHealth format: "SURNAME, FIRSTNAME MIDDLENAME"
  const namePattern = /^([A-Z][A-Z\s\-']{1,25})\s*,\s*([A-Z][A-Z\s\-']{3,40})$/;
  
  for (let i = 0; i < cleanLines.length; i++) {
    let line = cleanLines[i];
    
    // Clean the line - remove noise characters
    let cleanLine = line
      .replace(/[|\\\/\=\+\*\@\#\$\%\^\&\[\]\{\}\(\)]/g, ' ')
      .replace(/\s+/g, ' ')
      .replace(/^[0-9IVX\$\&\-\s]+/, '')
      .replace(/[0-9IVX\$\&\-\s]+$/, '')
      .trim();
    
    console.log('üîç Checking line for name:', cleanLine);
    
    // Skip non-name lines
    if (cleanLine.includes('PHILHEALTH') || 
        cleanLine.includes('PHILIPPINE') ||
        cleanLine.includes('REPUBLIC') ||
        cleanLine.includes('HEALTH') ||
        cleanLine.includes('INSURANCE') ||
        cleanLine.includes('CORPORATION') ||
        cleanLine.includes('STREET') ||
        cleanLine.includes('BARANGAY') ||
        cleanLine.includes('BGY') ||
        cleanLine.includes('BRGY') ||
        cleanLine.includes('DISTRICT') ||
        cleanLine.includes('CITY') ||
        cleanLine.includes('PROVINCE') ||
        cleanLine.includes('MANILA') ||
        cleanLine.includes('MEMBER') ||
        cleanLine.includes('DEPENDENT') ||
        cleanLine.includes('SIGNATURE') ||
        /\d{2}[-\s]?\d{9}[-\s]?\d/.test(cleanLine) ||
        /\d{4}[-\/]\d{2}[-\/]\d{2}/.test(cleanLine) ||
        /(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)\s+\d{1,2}/i.test(cleanLine) ||
        cleanLine.includes('FEMALE') ||
        cleanLine.includes('MALE') ||
        cleanLine.length < 8 ||
        cleanLine.length > 50) {
      continue;
    }
    
    // Must have a comma for PhilHealth name format
    if (!cleanLine.includes(',')) {
      continue;
    }
    
    const match = cleanLine.match(namePattern);
    if (match) {
      const surname = match[1].trim();
      const firstMiddle = match[2].trim();
      
      console.log('üîç Potential match - Surname:', surname, 'First+Middle:', firstMiddle);
      
      // Validate: no numbers or special chars in name
      if (!/[0-9\{\}\[\]\(\)\=\|\+\*\@\#\$\%\^\&]/.test(surname) &&
          !/[0-9\{\}\[\]\(\)\=\|\+\*\@\#\$\%\^\&]/.test(firstMiddle)) {
        
        const surnameWords = surname.split(/\s+/).filter(w => w.length > 0);
        const firstMiddleWords = firstMiddle.split(/\s+/).filter(w => w.length > 0);
        
        // Surname: 1-2 words, First+Middle: 2-4 words
        if (surnameWords.length >= 1 && surnameWords.length <= 2 &&
            firstMiddleWords.length >= 2 && firstMiddleWords.length <= 4 &&
            surname.length >= 2 && surname.length <= 25 &&
            firstMiddle.length >= 4 && firstMiddle.length <= 40) {
          
          // Output Format: FIRSTNAME MIDDLENAME SURNAME
          const fullName = `${firstMiddle} ${surname}`;
          console.log('‚úÖ Extracted Full Name (First Middle Surname):', fullName);
          return fullName;
        }
      }
    }
  }
  
  // Fallback: Try to find name near the ID number
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // If this line looks like an ID number, check the next line for name
    if (/\d{2}[-\s]?\d{9}[-\s]?\d/.test(line)) {
      const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
      
      if (nextLine && nextLine.includes(',')) {
        const cleanNext = nextLine
          .replace(/[|\\\/\=\+\*\@\#\$\%\^\&\[\]\{\}\(\)]/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
        
        const match = cleanNext.match(namePattern);
        if (match) {
          const surname = match[1].trim();
          const firstMiddle = match[2].trim();
          
          // Output Format: FIRSTNAME MIDDLENAME SURNAME
          const fullName = `${firstMiddle} ${surname}`;
          console.log('‚úÖ Extracted Full Name (after ID number):', fullName);
          return fullName;
        }
      }
    }
  }
  
  console.log('‚ùå No valid PhilHealth name found');
  return null;
};

/**
 * PhilHealth Sex Extraction - IMPROVED VERSION
 * Format: "APRIL 15, 1978 - FEMALE" (same line as birthday, after dash)
 */
const extractPhilHealthSex = (lines) => {
  console.log('üë§ Extracting PhilHealth Sex');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Pattern 1: Date followed by dash and sex
    const sexAfterDatePattern = /(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)\s+\d{1,2},?\s+\d{4}\s*[-‚Äì‚Äî]\s*(MALE|FEMALE)/i;
    const sexMatch = line.match(sexAfterDatePattern);
    
    if (sexMatch) {
      const sex = sexMatch[2].toUpperCase() === 'FEMALE' ? 'Female' : 'Male';
      console.log('‚úÖ Found Sex (after date):', sex);
      return sex;
    }
    
    // Pattern 2: Line ends with MALE or FEMALE
    const lineUpper = line.toUpperCase().trim();
    if (lineUpper.endsWith('FEMALE')) {
      console.log('‚úÖ Found Sex (line ends with FEMALE):', 'Female');
      return 'Female';
    }
    if (lineUpper.endsWith('MALE') && !lineUpper.endsWith('FEMALE')) {
      console.log('‚úÖ Found Sex (line ends with MALE):', 'Male');
      return 'Male';
    }
    
    // Pattern 3: Dash followed by sex anywhere in line
    const dashSexPattern = /[-‚Äì‚Äî]\s*(MALE|FEMALE)/i;
    const dashMatch = line.match(dashSexPattern);
    if (dashMatch) {
      const sex = dashMatch[1].toUpperCase() === 'FEMALE' ? 'Female' : 'Male';
      console.log('‚úÖ Found Sex (after dash):', sex);
      return sex;
    }
    
    // Pattern 4: Standalone MALE or FEMALE on a line (after a date line)
    if (lineUpper === 'FEMALE' || lineUpper === 'MALE') {
      if (i > 0) {
        const prevLine = lines[i - 1];
        if (/(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)\s+\d{1,2}/i.test(prevLine) ||
            /\d{4}/.test(prevLine)) {
          const sex = lineUpper === 'FEMALE' ? 'Female' : 'Male';
          console.log('‚úÖ Found Sex (standalone after date):', sex);
          return sex;
        }
      }
    }
  }
  
  console.log('‚ùå No PhilHealth sex found');
  return null;
};

/**
 * PhilHealth Birthday Extraction - REVISED VERSION
 * Input Format: "APRIL 15, 1978" (MONTH DAY, YEAR)
 * Output Format: "04-15-1978" (MM-DD-YYYY)
 */
const extractPhilHealthBirthday = (lines) => {
  console.log('üìÖ Extracting PhilHealth Birthday');
  
  // Month name to number conversion
  const monthNames = {
    'JANUARY': '01', 'FEBRUARY': '02', 'MARCH': '03', 'APRIL': '04',
    'MAY': '05', 'JUNE': '06', 'JULY': '07', 'AUGUST': '08',
    'SEPTEMBER': '09', 'OCTOBER': '10', 'NOVEMBER': '11', 'DECEMBER': '12'
  };
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Pattern: "MONTH DAY, YEAR" or "MONTH DAY YEAR"
    // Examples: "APRIL 15, 1978", "APRIL 15, 1978 - FEMALE"
    const datePattern = /(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)\s+(\d{1,2}),?\s+(\d{4})/i;
    const match = line.match(datePattern);
    
    if (match) {
      const monthText = match[1].toUpperCase();
      const day = match[2].padStart(2, '0');
      const year = match[3];
      const month = monthNames[monthText];
      
      if (month) {
        // Validate year is reasonable for a birthday
        const yearInt = parseInt(year);
        if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
          // Output Format: MM-DD-YYYY
          const formattedDate = `${month}-${day}-${year}`;
          console.log('‚úÖ Found Birthday (MM-DD-YYYY):', formattedDate);
          return formattedDate;
        }
      }
    }
    
    // Pattern 2: Check combined lines
    if (i + 1 < lines.length) {
      const combinedLine = line + ' ' + lines[i + 1];
      const combinedMatch = combinedLine.match(datePattern);
      
      if (combinedMatch) {
        const monthText = combinedMatch[1].toUpperCase();
        const day = combinedMatch[2].padStart(2, '0');
        const year = combinedMatch[3];
        const month = monthNames[monthText];
        
        if (month) {
          const yearInt = parseInt(year);
          if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
            // Output Format: MM-DD-YYYY
            const formattedDate = `${month}-${day}-${year}`;
            console.log('‚úÖ Found Birthday (combined, MM-DD-YYYY):', formattedDate);
            return formattedDate;
          }
        }
      }
    }
  }
  
  // Fallback: Look for numeric date patterns and convert
  for (let line of lines) {
    // Skip address lines
    if (line.includes('STREET') || line.includes('BGY') || 
        line.includes('BRGY') || line.includes('DISTRICT')) {
      continue;
    }
    
    // Pattern: YYYY-MM-DD (convert to MM-DD-YYYY)
    const isoPattern = /(\d{4})[-\/](\d{2})[-\/](\d{2})/;
    const isoMatch = line.match(isoPattern);
    if (isoMatch) {
      const year = isoMatch[1];
      const month = isoMatch[2];
      const day = isoMatch[3];
      const yearInt = parseInt(year);
      
      if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
        // Output Format: MM-DD-YYYY
        const formattedDate = `${month}-${day}-${year}`;
        console.log('‚úÖ Found Birthday (converted from ISO, MM-DD-YYYY):', formattedDate);
        return formattedDate;
      }
    }
    
    // Pattern: MM/DD/YYYY or MM-DD-YYYY (already correct format, just normalize separator)
    const mmddPattern = /(\d{2})[-\/](\d{2})[-\/](\d{4})/;
    const mmddMatch = line.match(mmddPattern);
    if (mmddMatch) {
      const part1 = mmddMatch[1];
      const part2 = mmddMatch[2];
      const year = mmddMatch[3];
      const yearInt = parseInt(year);
      
      if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
        // Assume MM-DD-YYYY format
        const formattedDate = `${part1}-${part2}-${year}`;
        console.log('‚úÖ Found Birthday (numeric, MM-DD-YYYY):', formattedDate);
        return formattedDate;
      }
    }
  }
  
  console.log('‚ùå No PhilHealth birthday found');
  return null;
};

/**
 * PhilHealth Address Extraction - IMPROVED VERSION
 * Format: "1503-D FABIE STREET BGY 815 PACO, SIXTH DISTRICT"
 */
const extractPhilHealthAddress = (lines) => {
  console.log('üè† Extracting PhilHealth Address');
  
  let addressCandidates = [];
  
  // Address keywords
  const addressKeywords = [
    'STREET', 'ST.', 'ST ',
    'AVENUE', 'AVE.', 'AVE ',
    'ROAD', 'RD.', 'RD ',
    'BOULEVARD', 'BLVD',
    'DRIVE', 'DR.',
    'LANE', 'LN.',
    'BGY', 'BRGY', 'BARANGAY',
    'DISTRICT', 'ZONE', 'PUROK',
    'SUBDIVISION', 'SUBD', 'VILL', 'VILLAGE',
    'COMPOUND', 'BLDG', 'BUILDING',
    'PHASE', 'BLOCK', 'LOT', 'FLOOR'
  ];
  
  // City/Location keywords
  const locationKeywords = [
    'MANILA', 'QUEZON', 'MAKATI', 'PASIG', 'TAGUIG', 'PASAY',
    'CALOOCAN', 'MARIKINA', 'MUNTINLUPA', 'PARANAQUE', 'LAS PINAS',
    'VALENZUELA', 'MALABON', 'NAVOTAS', 'PATEROS',
    'PACO', 'TONDO', 'SAMPALOC', 'SANTA ANA', 'ERMITA', 'MALATE',
    'INTRAMUROS', 'BINONDO', 'QUIAPO', 'SAN MIGUEL',
    'NCR', 'METRO MANILA'
  ];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineUpper = line.toUpperCase();
    
    // Skip non-address lines
    if (lineUpper.includes('PHILHEALTH') ||
        lineUpper.includes('PHILIPPINE') ||
        lineUpper.includes('HEALTH') ||
        lineUpper.includes('INSURANCE') ||
        lineUpper.includes('CORPORATION') ||
        lineUpper.includes('REPUBLIC') ||
        lineUpper.includes('MEMBER') ||
        lineUpper.includes('DEPENDENT') ||
        lineUpper.includes('SIGNATURE') ||
        /^\d{2}[-\s]?\d{9}[-\s]?\d$/.test(line.replace(/\s/g, '')) ||
        /^[A-Z]+,\s*[A-Z\s]+$/.test(line) ||
        /(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)\s+\d{1,2},?\s+\d{4}/i.test(line) ||
        lineUpper === 'FEMALE' ||
        lineUpper === 'MALE' ||
        line.length < 10) {
      continue;
    }
    
    // Score the line
    let score = 0;
    let hasAddressKeyword = false;
    let hasLocationKeyword = false;
    let hasNumber = /\d/.test(line);
    
    for (const keyword of addressKeywords) {
      if (lineUpper.includes(keyword)) {
        hasAddressKeyword = true;
        score += 3;
        break;
      }
    }
    
    for (const location of locationKeywords) {
      if (lineUpper.includes(location)) {
        hasLocationKeyword = true;
        score += 2;
        break;
      }
    }
    
    if (hasNumber) score += 2;
    
    // Pattern: Number followed by text
    if (/^\d+[-\s]?[A-Z]?\s+[A-Z]/.test(lineUpper)) {
      score += 3;
    }
    
    // Pattern: Building/Unit number like "1503-D"
    if (/\d+[-\s]?[A-Z]/.test(line)) {
      score += 2;
    }
    
    if (score >= 3 || hasAddressKeyword || (hasLocationKeyword && hasNumber)) {
      let cleaned = line
        .replace(/\s+/g, ' ')
        .replace(/[=\|]+/g, '')
        .replace(/PACQO/g, 'PACO')
        .replace(/DIST\s*RIC\s*R?/gi, 'DISTRICT')
        .trim()
        .replace(/\s*,\s*$/, '');
      
      addressCandidates.push({
        line: cleaned,
        score: score,
        index: i
      });
    }
  }
  
  console.log('üìç Address candidates:', addressCandidates);
  
  if (addressCandidates.length === 0) {
    console.log('‚ùå No PhilHealth address found');
    return null;
  }
  
  // Sort by score
  addressCandidates.sort((a, b) => b.score - a.score);
  
  // Combine consecutive lines if applicable
  const bestCandidate = addressCandidates[0];
  let fullAddress = bestCandidate.line;
  
  for (const candidate of addressCandidates) {
    if (candidate.index === bestCandidate.index + 1 && candidate.score >= 2) {
      fullAddress += ', ' + candidate.line;
      break;
    }
  }
  
  console.log('‚úÖ Found Address:', fullAddress);
  return fullAddress;
};

/**
 * PhilHealth ID Number Extraction
 * Format: "19-025542778-8" (XX-XXXXXXXXX-X)
 */
const extractPhilHealthIDNumber = (lines) => {
  console.log('üî¢ Extracting PhilHealth ID Number');
  
  for (let line of lines) {
    // Pattern: XX-XXXXXXXXX-X (2 digits - 9 digits - 1 digit)
    const idPattern = /\b(\d{2})[-\s]?(\d{9})[-\s]?(\d)\b/;
    const match = line.match(idPattern);
    
    if (match) {
      const idNumber = `${match[1]}-${match[2]}-${match[3]}`;
      console.log('‚úÖ Found PhilHealth ID Number:', idNumber);
      return idNumber;
    }
  }
  
  console.log('‚ùå No PhilHealth ID number found');
  return null;
};
