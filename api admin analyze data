app.post('/api/admin/analyze-data', authenticateToken, async (req, res) => {
  try {
    if (req.user.type !== 'admin') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const { query } = req.body;
    const today = new Date().toISOString().split('T')[0];
    
    // Calculate date ranges
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    const weekAgoStr = oneWeekAgo.toISOString().split('T')[0];
    
    const oneMonthAgo = new Date();
    oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
    const monthAgoStr = oneMonthAgo.toISOString().split('T')[0];
    
    const oneYearAgo = new Date();
    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
    const yearAgoStr = oneYearAgo.toISOString().split('T')[0];
    
    console.log('üìä Fetching comprehensive hospital data...');
    console.log('üìù User query:', query);
    const startTime = Date.now();
    
    let contextData = {
      core: {
        totalPatients: 0,
        todayVisits: 0,
        newThisWeek: 0,
        appointments: 0,
        activeDoctors: 0,
        checkedIn: 0,
        completed: 0
      },
      departments: {},
      departmentStats: {},
      queue: { waiting: 0, inProgress: 0, completed: 0 },
      symptoms: [],
      departmentSymptoms: {},
      avgWaitTime: 0,
      timeData: {
        hourlyRegistrations: {},
        dailyRegistrations: {},
        weeklyRegistrations: {},
        monthlyRegistrations: {},
        departmentByDay: {},
        departmentByHour: {}
      }
    };
    
    try {
      // ============================================================================
      // ENHANCED DATA FETCHING WITH TIME-SERIES
      // ============================================================================
      const [
        { count: totalPatients },
        { count: todayVisits },
        { count: newThisWeek },
        { count: todayAppointments },
        { count: activeDoctors },
        { data: queueData },
        { data: symptomData },
        { data: visitData },
        { data: allDepartments },
        { data: departmentQueueStats },
        // NEW: Historical registration data
        { data: allRegistrations },
        { data: allVisits },
        { data: hourlyQueueData }
      ] = await Promise.all([
        supabase.from('outpatient').select('*', { count: 'exact', head: true }),
        supabase.from('visit').select('*', { count: 'exact', head: true }).eq('visit_date', today),
        supabase.from('outpatient').select('*', { count: 'exact', head: true }).gte('registration_date', weekAgoStr),
        supabase.from('pre_registration').select('*', { count: 'exact', head: true }).eq('scheduled_date', today).in('status', ['pending', 'completed']),
        supabase.from('staff').select('*', { count: 'exact', head: true }).eq('role', 'Doctor').eq('is_online', true),
        supabase.from('queue').select('queue_id, status, department:department_id(name), created_time, updated_at, scheduled_date').eq('scheduled_date', today),
        supabase.from('visit').select('symptoms').eq('visit_date', today).not('symptoms', 'is', null).limit(50),
        supabase.from('visit').select('symptoms, visit_date, queue(department:department_id(name))').not('symptoms', 'is', null).limit(200),
        supabase.from('department').select('department_id, name').eq('status', 'active'),
        supabase.from('queue').select('department_id, status, created_time, scheduled_date, department!inner(name)').order('created_time', { ascending: false }).limit(500),
        // NEW: Get ALL patient registrations with timestamps
        supabase.from('outpatient').select('registration_date, created_at').gte('registration_date', yearAgoStr).order('registration_date', { ascending: true }),
        // NEW: Get ALL visits with department and timestamp
        supabase.from('visit').select('visit_id, visit_date, visit_time, queue(department_id, department!inner(name))').gte('visit_date', yearAgoStr).order('visit_date', { ascending: true }),
        // NEW: Queue data with timestamps for hourly analysis
        supabase.from('queue').select('created_time, scheduled_date, department_id, department!inner(name)').gte('scheduled_date', monthAgoStr)
      ]);
      
      console.log(`‚úÖ All data fetched in ${Date.now() - startTime}ms`);
      
      // ============================================================================
      // EXISTING DATA PROCESSING (Keep your current logic)
      // ============================================================================
      
      // Process department data with queue counts
      const deptSummary = {};
      const deptQueueCounts = {};
      const queueSummary = { waiting: 0, inProgress: 0, completed: 0 };
      const waitTimes = [];
      
      (queueData || []).forEach(q => {
        const dept = q.department?.name || 'Unknown';
        deptSummary[dept] = (deptSummary[dept] || 0) + 1;
        
        if (q.status === 'waiting') queueSummary.waiting++;
        else if (q.status === 'in_progress') queueSummary.inProgress++;
        else if (q.status === 'completed') queueSummary.completed++;
        
        if (q.created_time) {
          const created = new Date(q.created_time);
          const updated = q.updated_at ? new Date(q.updated_at) : new Date();
          const waitMinutes = Math.floor((updated - created) / 60000);
          if (waitMinutes >= 0) waitTimes.push(waitMinutes);
        }
      });

      (allDepartments || []).forEach(dept => {
        const deptQueues = (departmentQueueStats || []).filter(q => q.department_id === dept.department_id);
        deptQueueCounts[dept.name] = {
          total: deptQueues.length,
          waiting: deptQueues.filter(q => q.status === 'waiting').length,
          completed: deptQueues.filter(q => q.status === 'completed').length
        };
      });
      
      // Process symptoms
      const symptomCounts = {};
      (symptomData || []).forEach(v => {
        if (v.symptoms) {
          v.symptoms.split(',').forEach(symptom => {
            const clean = symptom.trim();
            if (clean && !clean.toLowerCase().includes('lab') && !clean.toLowerCase().includes('test') && clean.length > 2) {
              symptomCounts[clean] = (symptomCounts[clean] || 0) + 1;
            }
          });
        }
      });
      
      const topSymptoms = Object.entries(symptomCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

      // Department-specific symptoms
      const deptSymptoms = {};
      (visitData || []).forEach(v => {
        if (!v.symptoms) return;
        
        let deptName = null;
        if (Array.isArray(v.queue)) {
          if (v.queue.length > 0 && v.queue[0]?.department?.name) {
            deptName = v.queue[0].department.name;
          }
        } else if (v.queue?.department?.name) {
          deptName = v.queue.department.name;
        }
      
        if (!deptName) return;
        
        if (!deptSymptoms[deptName]) deptSymptoms[deptName] = {};
        
        v.symptoms.split(',').forEach(symptom => {
          const clean = symptom.trim();
          if (clean && !clean.toLowerCase().includes('lab') && !clean.toLowerCase().includes('test') && clean.length > 2) {
            deptSymptoms[deptName][clean] = (deptSymptoms[deptName][clean] || 0) + 1;
          }
        });
      });

      // ============================================================================
      // NEW: COMPREHENSIVE TIME-SERIES ANALYSIS
      // ============================================================================
      
      // 1. HOURLY REGISTRATION PATTERN (All time)
      const hourlyStats = {};
      (allRegistrations || []).forEach(patient => {
        if (patient.created_at) {
          const hour = new Date(patient.created_at).getHours();
          hourlyStats[hour] = (hourlyStats[hour] || 0) + 1;
        }
      });
      
      // 2. DAILY REGISTRATIONS (Last 30 days)
      const dailyStats = {};
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      
      (allRegistrations || []).forEach(patient => {
        const regDate = new Date(patient.registration_date);
        if (regDate >= thirtyDaysAgo) {
          const dateKey = patient.registration_date;
          dailyStats[dateKey] = (dailyStats[dateKey] || 0) + 1;
        }
      });
      
      // 3. WEEKLY PATTERN (Day of week analysis)
      const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const weeklyStats = {};
      daysOfWeek.forEach(day => {
        weeklyStats[day] = { total: 0, departments: {} };
      });
      
      (allVisits || []).forEach(visit => {
        const dayOfWeek = new Date(visit.visit_date).getDay();
        const dayName = daysOfWeek[dayOfWeek];
        
        weeklyStats[dayName].total++;
        
        // Track by department
        let deptName = null;
        if (Array.isArray(visit.queue)) {
          if (visit.queue.length > 0 && visit.queue[0]?.department?.name) {
            deptName = visit.queue[0].department.name;
          }
        } else if (visit.queue?.department?.name) {
          deptName = visit.queue.department.name;
        }
        
        if (deptName) {
          if (!weeklyStats[dayName].departments[deptName]) {
            weeklyStats[dayName].departments[deptName] = 0;
          }
          weeklyStats[dayName].departments[deptName]++;
        }
      });
      
      // 4. MONTHLY PATTERN (Last 12 months)
      const monthlyStats = {};
      const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                          'July', 'August', 'September', 'October', 'November', 'December'];
      
      (allRegistrations || []).forEach(patient => {
        const date = new Date(patient.registration_date);
        const monthKey = `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
        monthlyStats[monthKey] = (monthlyStats[monthKey] || 0) + 1;
      });
      
      // 5. DEPARTMENT BY DAY OF WEEK
      const departmentByDay = {};
      (allVisits || []).forEach(visit => {
        const dayOfWeek = daysOfWeek[new Date(visit.visit_date).getDay()];
        
        let deptName = null;
        if (Array.isArray(visit.queue)) {
          if (visit.queue.length > 0 && visit.queue[0]?.department?.name) {
            deptName = visit.queue[0].department.name;
          }
        } else if (visit.queue?.department?.name) {
          deptName = visit.queue.department.name;
        }
        
        if (deptName) {
          if (!departmentByDay[deptName]) {
            departmentByDay[deptName] = {};
            daysOfWeek.forEach(day => departmentByDay[deptName][day] = 0);
          }
          departmentByDay[deptName][dayOfWeek]++;
        }
      });
      
      // 6. DEPARTMENT BY HOUR OF DAY
      const departmentByHour = {};
      (hourlyQueueData || []).forEach(queue => {
        if (queue.created_time && queue.department?.name) {
          const hour = new Date(queue.created_time).getHours();
          const deptName = queue.department.name;
          
          if (!departmentByHour[deptName]) {
            departmentByHour[deptName] = {};
          }
          departmentByHour[deptName][hour] = (departmentByHour[deptName][hour] || 0) + 1;
        }
      });
      
      // ============================================================================
      // UPDATE CONTEXT DATA
      // ============================================================================
      contextData = {
        core: {
          totalPatients: totalPatients || 0,
          todayVisits: todayVisits || 0,
          newThisWeek: newThisWeek || 0,
          appointments: todayAppointments || 0,
          activeDoctors: activeDoctors || 0,
          checkedIn: queueSummary.waiting + queueSummary.inProgress,
          completed: queueSummary.completed
        },
        departments: deptSummary,
        departmentStats: deptQueueCounts,
        queue: queueSummary,
        symptoms: topSymptoms,
        departmentSymptoms: deptSymptoms,
        avgWaitTime: waitTimes.length > 0 ? Math.round(waitTimes.reduce((a, b) => a + b, 0) / waitTimes.length) : 0,
        // NEW: Time-series data
        timeData: {
          hourlyRegistrations: hourlyStats,
          dailyRegistrations: dailyStats,
          weeklyPattern: weeklyStats,
          monthlyRegistrations: monthlyStats,
          departmentByDay: departmentByDay,
          departmentByHour: departmentByHour
        }
      };
      
    } catch (error) {
      console.error('‚ùå Database error:', error);
      return res.status(500).json({ error: 'Database query failed' });
    }
    
    // ============================================================================
    // PII CHECK (Keep your existing logic)
    // ============================================================================
    const lowerQuery = query.toLowerCase();
    
    const strictPIIPatterns = [
      /\bpatient\s+(id|name|contact|phone|email|address)\b/,
      /\bwho\s+is\s+patient\b/,
      /\blist\s+(of|all)\s+patient/,
      /\bshow\s+me\s+patient\s+(details|info|data|names|contacts)/,
      /\bgive\s+me\s+(patient|name|contact|phone|email)/,
      /\bpatient\s+named\b/,
      /\bname\s+of\s+patient/,
      /\bcontact\s+(info|details|number)\s+of\s+patient/
    ];

    const isPIIRequest = strictPIIPatterns.some(pattern => pattern.test(lowerQuery));

    const isStatisticalQuery = 
      lowerQuery.includes('how many') ||
      lowerQuery.includes('total') ||
      lowerQuery.includes('count') ||
      lowerQuery.includes('number of') ||
      lowerQuery.includes('top') ||
      lowerQuery.includes('compare') ||
      lowerQuery.includes('busiest') ||
      lowerQuery.includes('highest') ||
      lowerQuery.includes('lowest') ||
      lowerQuery.includes('average') ||
      lowerQuery.includes('statistics') ||
      lowerQuery.includes('department') ||
      lowerQuery.includes('symptom') ||
      lowerQuery.includes('queue');

    if (isPIIRequest && !isStatisticalQuery) {
      console.log('üö´ PII request detected, blocking');
      return res.json({
        textResponse: "I can't provide individual patient information due to RA 10173 (Data Privacy Act). Instead, I can help you with:\n\n" +
          "‚úÖ Aggregate statistics (total patients, visit counts)\n" +
          "‚úÖ Department comparisons and performance\n" +
          "‚úÖ Symptom trends and patterns\n" +
          "‚úÖ Queue analytics and wait times\n" +
          "‚úÖ Peak hours and busiest days\n\n" +
          "What statistical insights would you like to see?",
        chartType: null,
        chartData: [],
        chartTitle: null
      });
    }
    
    // ============================================================================
    // ENHANCED GEMINI PROMPT WITH TIME DATA
    // ============================================================================
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });

    // Find peak hour and busiest day
    const peakHour = Object.entries(contextData.timeData.hourlyRegistrations)
      .sort((a, b) => b[1] - a[1])[0];
    
    const busiestDay = Object.entries(contextData.timeData.weeklyPattern)
      .sort((a, b) => b[1].total - a[1].total)[0];
    
    // Top departments by queue
    const topDepartmentsByQueue = Object.entries(contextData.departmentStats)
      .sort((a, b) => b[1].total - a[1].total)
      .slice(0, 5);

    const context = `You are a hospital analytics assistant. Today: ${today}

  CURRENT STATISTICS:
  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  üìä PATIENT METRICS:
  - Total Registered: ${contextData.core.totalPatients}
  - Today's Visits: ${contextData.core.todayVisits}
  - This Week: ${contextData.core.newThisWeek}
  - Currently Checked In: ${contextData.core.checkedIn}
  - Completed Today: ${contextData.core.completed}

  üè• DEPARTMENT STATS:
  ${Object.entries(contextData.departmentStats).map(([dept, stats]) => 
    `‚Ä¢ ${dept}: ${stats.total} total (${stats.waiting} waiting, ${stats.completed} completed)`
  ).join('\n')}

  üìã TOP DEPARTMENTS BY QUEUE:
  ${topDepartmentsByQueue.map(([dept, stats], i) => `${i+1}. ${dept}: ${stats.total} patients`).join('\n')}

  ü©∫ TOP SYMPTOMS:
  ${contextData.symptoms.slice(0, 5).map(([symptom, count], i) => `${i+1}. ${symptom}: ${count} cases`).join('\n')}

  ‚è∞ PEAK REGISTRATION TIME: ${peakHour ? `${peakHour[0]}:00 (${peakHour[1]} registrations)` : 'No data'}

  üìÖ BUSIEST DAY: ${busiestDay ? `${busiestDay[0]} (${busiestDay[1].total} visits)` : 'No data'}

  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  üìà TIME-SERIES DATA AVAILABLE:
  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

  üïê HOURLY PATTERN (All registrations by hour):
  ${Object.entries(contextData.timeData.hourlyRegistrations)
    .sort((a, b) => parseInt(a[0]) - parseInt(b[0]))
    .map(([hour, count]) => `${hour}:00 - ${count} registrations`)
    .join(', ')}

  üìÖ DAILY REGISTRATIONS (Last 30 days):
  ${Object.entries(contextData.timeData.dailyRegistrations)
    .slice(-7)
    .map(([date, count]) => `${date}: ${count}`)
    .join(', ')}
  ... and ${Object.keys(contextData.timeData.dailyRegistrations).length} more days available

  üìä WEEKLY PATTERN (By day of week):
  ${Object.entries(contextData.timeData.weeklyPattern)
    .map(([day, data]) => `${day}: ${data.total} visits`)
    .join('\n')}

  üìà DEPARTMENT BUSIEST DAYS:
  ${Object.entries(contextData.timeData.departmentByDay)
    .slice(0, 3)
    .map(([dept, days]) => {
      const busiestDayForDept = Object.entries(days).sort((a, b) => b[1] - a[1])[0];
      return `${dept}: Busiest on ${busiestDayForDept[0]} (${busiestDayForDept[1]} visits)`;
    })
    .join('\n')}

  ‚è∞ DEPARTMENT PEAK HOURS:
  ${Object.entries(contextData.timeData.departmentByHour)
    .slice(0, 3)
    .map(([dept, hours]) => {
      const peakHourForDept = Object.entries(hours).sort((a, b) => b[1] - a[1])[0];
      return `${dept}: Peak at ${peakHourForDept[0]}:00 (${peakHourForDept[1]} visits)`;
    })
    .join('\n')}

  USER QUESTION: "${query}"

  RESPONSE RULES:
  ‚úÖ ANSWER THESE FREELY (aggregate statistics):
  - Total patient counts by date/month/year
  - Department comparisons
  - Symptom trends  
  - Queue statistics
  - Busiest times/days for ANY department
  - Peak registration hours
  - Wait times
  - Historical trends

  ‚ùå NEVER PROVIDE:
  - Individual patient names, IDs, or contact info
  - Specific personal health details

  RESPONSE FORMAT (JSON):
  {
    "textResponse": "Direct answer with relevant statistics and insights",
    "chartType": "bar|pie|line",
    "chartData": [{"name": "X", "value": Y}],
    "chartTitle": "Descriptive title"
  }

  EXAMPLES:

  Q: "Busiest day of the week for Internal Medicine"
  A: Look at departmentByDay for Internal Medicine, find highest value, create bar chart

  Q: "How many patients in November 2024?"
  A: Sum all monthlyRegistrations entries for "November 2024"

  Q: "What time do most patients register?"
  A: Look at hourlyRegistrations, find peak hour, create line chart

  Q: "Compare Surgery vs Pediatrics by day of week"
  A: Use departmentByDay data for both, create comparison bar chart

  Be conversational but data-driven. Always include relevant charts with actual data.`;

    const geminiStart = Date.now();
    const result = await model.generateContent(context);
    console.log(`‚úÖ Gemini responded in ${Date.now() - geminiStart}ms`);
    
    const response = await result.response;
    let text = response.text().replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    let parsedResponse;
    try {
      parsedResponse = JSON.parse(text);
    } catch (parseError) {
      console.error('‚ùå Parse error:', parseError);
      
      return res.json({
        textResponse: `Here's your hospital overview for ${today}:\n\n` +
          `‚Ä¢ Total Patients: ${contextData.core.totalPatients}\n` +
          `‚Ä¢ Today's Visits: ${contextData.core.todayVisits}\n` +
          `‚Ä¢ Peak Hour: ${peakHour ? `${peakHour[0]}:00` : 'N/A'}\n` +
          `‚Ä¢ Busiest Day: ${busiestDay ? busiestDay[0] : 'N/A'}`,
        chartType: "bar",
        chartData: [
          {"name": "Today", "value": contextData.core.todayVisits},
          {"name": "This Week", "value": contextData.core.newThisWeek},
          {"name": "Total", "value": contextData.core.totalPatients}
        ],
        chartTitle: "Hospital Overview"
      });
    }

    // PII check in response
    const responseText = parsedResponse.textResponse || '';
    if (/\bPAT\d{9}\b|\b09\d{9}\b|@[a-z]+\.[a-z]+/i.test(responseText)) {
      return res.json({
        textResponse: "I can't provide individual patient information due to RA 10173.",
        chartType: null,
        chartData: [],
        chartTitle: null
      });
    }

    // Ensure chart exists
    const isPrivacyResponse = responseText.includes('RA 10173') || 
                              responseText.includes('individual patient information');

    if (isPrivacyResponse) {
      parsedResponse.chartType = null;
      parsedResponse.chartData = [];
      parsedResponse.chartTitle = null;
    } else if (!parsedResponse.chartData || parsedResponse.chartData.length === 0) {
      // Intelligent fallback
      if (lowerQuery.includes('hour')) {
        parsedResponse.chartType = 'line';
        parsedResponse.chartData = Object.entries(contextData.timeData.hourlyRegistrations)
          .sort((a, b) => parseInt(a[0]) - parseInt(b[0]))
          .map(([hour, count]) => ({ name: `${hour}:00`, value: count }));
        parsedResponse.chartTitle = 'Hourly Registration Distribution';
      } else if (lowerQuery.includes('day') || lowerQuery.includes('week')) {
        parsedResponse.chartType = 'bar';
        parsedResponse.chartData = Object.entries(contextData.timeData.weeklyPattern)
          .map(([day, stats]) => ({ name: day, value: stats.total }));
        parsedResponse.chartTitle = 'Weekly Visit Distribution';
      } else {
        parsedResponse.chartType = 'bar';
        parsedResponse.chartData = [
          {"name": "Today", "value": contextData.core.todayVisits},
          {"name": "Total", "value": contextData.core.totalPatients}
        ];
        parsedResponse.chartTitle = "Hospital Overview";
      }
    }

    console.log(`‚úÖ Total request time: ${Date.now() - startTime}ms`);
    return res.json(parsedResponse);

  } catch (error) {
    console.error('‚ùå API Error:', error);
    res.status(500).json({ 
      textResponse: "System error occurred. Please try again.",
      chartType: null,
      chartData: [],
      chartTitle: null
    });
  }
}); 
