/**
 * UMID Name Extraction - IMPROVED VERSION with noise handling
 * Handles OCR noise like "4;5 SANTOS", "== JOSE", "2 CRUZ"
 */
const extractUMIDName = (lines) => {
  console.log('üìã UMID ID detected');
  console.log('üìÑ Lines:', lines);
  
  let surname = null;
  let givenName = null;
  let middleName = null;
  
  // Helper function to clean noise from name values
  const cleanNameValue = (text) => {
    return text
      // Remove common OCR noise prefixes
      .replace(/^[\d\s;:=\-\.\,\'\"\|\\\[\]\(\)\{\}%@#$&*!?<>~`]+/, '')
      // Remove common OCR noise suffixes
      .replace(/[\d\s;:=\-\.\,\'\"\|\\\[\]\(\)\{\}%@#$&*!?<>~`]+$/, '')
      // Remove isolated special characters
      .replace(/\s+[;:=\-\.\,\'\"\|\\\[\]\(\)\{\}]+\s+/g, ' ')
      // Normalize spaces
      .replace(/\s+/g, ' ')
      .trim();
  };
  
  // Helper function to check if text looks like a valid name
  const isValidNameText = (text) => {
    const cleaned = cleanNameValue(text);
    // Must be 2-25 chars, mostly letters
    if (cleaned.length < 2 || cleaned.length > 25) return false;
    // Must be at least 70% letters
    const letterCount = (cleaned.match(/[A-Z]/gi) || []).length;
    return letterCount / cleaned.length >= 0.7;
  };
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const upperLine = line.toUpperCase();
    const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : '';
    const nextUpperLine = nextLine.toUpperCase();
    
    // Skip header/system lines
    if (upperLine.includes('UMID') || 
        upperLine.includes('UNIFIED') ||
        upperLine.includes('MULTI-PURPOSE') ||
        upperLine.includes('IDENTIFICATION') ||
        upperLine.includes('REPUBLIC') ||
        upperLine.includes('PHILIPPINES') ||
        upperLine.includes('SSS') ||
        upperLine.includes('GSIS') ||
        upperLine.includes('PHILHEALTH') ||
        upperLine.includes('HDMF') ||
        upperLine.includes('PAG-IBIG') ||
        /CRN[-\s]?\d{4}[-\s]?\d{7}[-\s]?\d/i.test(line) ||
        line.length < 2) {
      continue;
    }
    
    // SURNAME detection - handle noisy labels
    if (upperLine.includes('SURNAME') || 
        upperLine.match(/S\s*U\s*R\s*N\s*A\s*M\s*E/) ||
        upperLine.endsWith('SURNAME')) {
      
      // Check if surname value is on the same line (after label)
      const surnameMatch = line.match(/SURNAME\s*[:\s]*([A-Z][A-Z\s\-']+)/i);
      if (surnameMatch && isValidNameText(surnameMatch[1])) {
        surname = cleanNameValue(surnameMatch[1]);
        console.log('‚úÖ Found Surname (same line):', surname);
      }
      // Otherwise check next line
      else if (nextLine && isValidNameText(nextLine)) {
        surname = cleanNameValue(nextLine);
        console.log('‚úÖ Found Surname (next line):', surname);
      }
    }
    
    // GIVEN NAME detection - handle noisy labels
    if (upperLine.includes('GIVEN') || 
        upperLine.match(/G\s*I\s*V\s*E\s*N/) ||
        upperLine.includes('NAML') || // OCR error for NAME
        upperLine.includes('NAMF')) { // OCR error for NAME
      
      // Check if given name value is on the same line
      const givenMatch = line.match(/(?:GIVEN\s*NAME?|NAML?E?)\s*[:\s]*([A-Z][A-Z\s\-']+)/i);
      if (givenMatch && isValidNameText(givenMatch[1])) {
        givenName = cleanNameValue(givenMatch[1]);
        console.log('‚úÖ Found Given Name (same line):', givenName);
      }
      // Otherwise check next line
      else if (nextLine && isValidNameText(nextLine)) {
        givenName = cleanNameValue(nextLine);
        console.log('‚úÖ Found Given Name (next line):', givenName);
      }
    }
    
    // MIDDLE NAME detection
    if (upperLine.includes('MIDDLE') || 
        upperLine.match(/M\s*I\s*D\s*D\s*L\s*E/)) {
      
      // Check if middle name value is on the same line
      const middleMatch = line.match(/MIDDLE\s*NAME?\s*[:\s]*([A-Z][A-Z\s\-']+)/i);
      if (middleMatch && isValidNameText(middleMatch[1])) {
        middleName = cleanNameValue(middleMatch[1]);
        console.log('‚úÖ Found Middle Name (same line):', middleName);
      }
      // Otherwise check next line
      else if (nextLine && isValidNameText(nextLine)) {
        middleName = cleanNameValue(nextLine);
        console.log('‚úÖ Found Middle Name (next line):', middleName);
      }
    }
  }
  
  // FALLBACK: If labels not found, try pattern-based extraction
  // Look for lines that look like names (2-25 chars, mostly letters, after cleaning)
  if (!surname || !givenName) {
    console.log('üîÑ Trying fallback name extraction...');
    
    const potentialNames = [];
    let foundCRN = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const upperLine = line.toUpperCase();
      
      // Skip until after CRN (names typically appear after CRN on UMID)
      if (upperLine.includes('CRN') || /\d{4}[-\s]?\d{7}[-\s]?\d/.test(line)) {
        foundCRN = true;
        continue;
      }
      
      // Skip non-name content
      if (upperLine.includes('ADDRESS') ||
          upperLine.includes('SEX') ||
          upperLine.includes('DATE') ||
          upperLine.includes('BIRTH') ||
          upperLine.includes('PAYAPA') ||
          upperLine.includes('STREET') ||
          upperLine.includes('CITY') ||
          upperLine.includes('MANILA') ||
          upperLine.includes('PHILIPPINES') ||
          /\d{4}[\/\-]\d{2}[\/\-]\d{2}/.test(line)) {
        continue;
      }
      
      // Clean the line and check if it's a valid name
      const cleaned = cleanNameValue(line);
      if (cleaned.length >= 2 && cleaned.length <= 25 && isValidNameText(cleaned)) {
        // Check it's not a label
        if (!cleaned.match(/^(SURNAME|GIVEN|MIDDLE|NAME|SEX|DATE|ADDRESS|CRN)$/i)) {
          potentialNames.push(cleaned);
          console.log('üìù Potential name found:', cleaned);
        }
      }
    }
    
    // Assign names based on UMID order: Surname, Given Name, Middle Name
    if (potentialNames.length >= 1 && !surname) {
      surname = potentialNames[0];
      console.log('‚úÖ Fallback Surname:', surname);
    }
    if (potentialNames.length >= 2 && !givenName) {
      givenName = potentialNames[1];
      console.log('‚úÖ Fallback Given Name:', givenName);
    }
    if (potentialNames.length >= 3 && !middleName) {
      middleName = potentialNames[2];
      console.log('‚úÖ Fallback Middle Name:', middleName);
    }
  }
  
  // Construct full name: GIVEN NAME + MIDDLE NAME + SURNAME
  if (givenName && surname) {
    let fullName = givenName;
    if (middleName) {
      fullName += ' ' + middleName;
    }
    fullName += ' ' + surname;
    console.log('‚úÖ Constructed Full Name:', fullName);
    return fullName;
  }
  
  // If only surname found, return it
  if (surname) {
    console.log('‚ö†Ô∏è Only surname found:', surname);
    return surname;
  }
  
  console.log('‚ùå No valid UMID name found');
  return null;
};

/**
 * UMID Sex Extraction - IMPROVED VERSION
 * Handles: "SEX M", "SEX F", or M/F near DATE OF BIRTH
 */
const extractUMIDSex = (lines) => {
  console.log('üë§ Extracting UMID Sex');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const upperLine = line.toUpperCase();
    
    // Pattern 1: "SEX M" or "SEX F" (with possible noise)
    const sexPattern = /SEX\s*[:\s]*([MF])\b/i;
    const match = upperLine.match(sexPattern);
    
    if (match) {
      const sex = match[1].toUpperCase() === 'M' ? 'Male' : 'Female';
      console.log('‚úÖ Found Sex:', sex);
      return sex;
    }
    
    // Pattern 2: Line contains SEX and M/F with DATE OF BIRTH
    const combinedPattern = /SEX\s*[:\s]*([MF])\s*DATE\s*OF\s*BIRTH/i;
    const combinedMatch = upperLine.match(combinedPattern);
    
    if (combinedMatch) {
      const sex = combinedMatch[1].toUpperCase() === 'M' ? 'Male' : 'Female';
      console.log('‚úÖ Found Sex (combined line):', sex);
      return sex;
    }
    
    // Pattern 3: Isolated M or F on a line (after cleaning noise)
    const cleanedLine = line.replace(/[^A-Za-z\s]/g, '').trim();
    if (cleanedLine === 'M' || cleanedLine === 'MALE') {
      console.log('‚úÖ Found Sex (isolated M):', 'Male');
      return 'Male';
    }
    if (cleanedLine === 'F' || cleanedLine === 'FEMALE') {
      console.log('‚úÖ Found Sex (isolated F):', 'Female');
      return 'Female';
    }
    
    // Pattern 4: M or F followed by date pattern
    const sexBeforeDatePattern = /\b([MF])\s+\d{4}[\/\-]\d{2}[\/\-]\d{2}/i;
    const sexDateMatch = line.match(sexBeforeDatePattern);
    if (sexDateMatch) {
      const sex = sexDateMatch[1].toUpperCase() === 'M' ? 'Male' : 'Female';
      console.log('‚úÖ Found Sex (before date):', sex);
      return sex;
    }
  }
  
  console.log('‚ùå No UMID sex found');
  return null;
};

/**
 * UMID Birthday Extraction - IMPROVED VERSION
 * Handles: YYYY/MM/DD, MM/DD/YYYY, with OCR noise
 */
const extractUMIDBirthday = (lines) => {
  console.log('üìÖ Extracting UMID Birthday');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Skip address lines
    if (line.includes('PAYAPA') || 
        line.includes('STREET') || 
        line.includes('ST ') ||
        line.includes('CITY') ||
        line.includes('MANILA') ||
        line.includes('PHILIPPINES')) {
      continue;
    }
    
    // Pattern 1: "DATE OF BIRTH YYYY/MM/DD"
    const dobPattern1 = /DATE\s*OF\s*BIRTH\s*[:\s]*(\d{4})[\/\-](\d{2})[\/\-](\d{2})/i;
    const match1 = line.match(dobPattern1);
    
    if (match1) {
      const year = match1[1];
      const month = match1[2];
      const day = match1[3];
      
      const yearInt = parseInt(year);
      if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
        const formattedDate = `${year}-${month}-${day}`;
        console.log('‚úÖ Found Birthday (DATE OF BIRTH YYYY/MM/DD):', formattedDate);
        return formattedDate;
      }
    }
    
    // Pattern 2: YYYY/MM/DD anywhere in line (not in address)
    const datePattern = /\b(\d{4})[\/\-](\d{2})[\/\-](\d{2})\b/;
    const dateMatch = line.match(datePattern);
    
    if (dateMatch) {
      const year = dateMatch[1];
      const month = dateMatch[2];
      const day = dateMatch[3];
      
      const yearInt = parseInt(year);
      // Valid birthday year range
      if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
        const formattedDate = `${year}-${month}-${day}`;
        console.log('‚úÖ Found Birthday (YYYY/MM/DD):', formattedDate);
        return formattedDate;
      }
    }
    
    // Pattern 3: MM/DD/YYYY format
    const mmddPattern = /\b(\d{2})[\/\-](\d{2})[\/\-](\d{4})\b/;
    const mmddMatch = line.match(mmddPattern);
    
    if (mmddMatch) {
      const month = mmddMatch[1];
      const day = mmddMatch[2];
      const year = mmddMatch[3];
      
      const yearInt = parseInt(year);
      if (yearInt >= 1900 && yearInt <= new Date().getFullYear()) {
        const formattedDate = `${year}-${month}-${day}`;
        console.log('‚úÖ Found Birthday (MM/DD/YYYY ‚Üí YYYY-MM-DD):', formattedDate);
        return formattedDate;
      }
    }
  }
  
  console.log('‚ùå No UMID birthday found');
  return null;
};

/**
 * UMID Address Extraction - IMPROVED VERSION with noise cleaning
 * Handles lines like: "- 28 PAYAPA ST BAGONG DIWA", "I STO CRISTOBAL CALOOCAN CITY"
 */
const extractUMIDAddress = (lines) => {
  console.log('üè† Extracting UMID Address');
  console.log('üìÑ All lines for address:', lines);
  
  let addressLines = [];
  
  // Helper function to clean address line noise
  const cleanAddressLine = (text) => {
    return text
      // Remove common OCR noise prefixes
      .replace(/^[\s\-\.\,\:\;\'\"\|\\_~=\[\]\(\)\{\}<>]+/, '')
      // Remove single character prefixes like "I ", "E ", "P, "
      .replace(/^[A-Z][\s\.\,]+/, '')
      // Remove noise suffixes
      .replace(/[\s\-\.\,\:\;\'\"\|\\_~=\[\]\(\)\{\}<>]+$/, '')
      // Normalize spaces
      .replace(/\s+/g, ' ')
      .trim();
  };
  
  // Address keywords to look for
  const addressKeywords = [
    'PAYAPA', 'BAGONG', 'DIWA',
    'CRISTOBAL', 'CALOOCAN', 'CITY',
    'METRO', 'MANILA', 'PHILIPPINES',
    'STREET', 'ST ', 'ST.',
    'BARANGAY', 'BRGY', 'BGY',
    'AVENUE', 'AVE', 'ROAD', 'RD',
    'VILLAGE', 'VILL', 'SUBD', 'SUBDIVISION'
  ];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const upperLine = line.toUpperCase();
    
    // Skip header/name/CRN lines
    if (upperLine.includes('UMID') ||
        upperLine.includes('UNIFIED') ||
        upperLine.includes('MULTI-PURPOSE') ||
        upperLine.includes('SURNAME') ||
        upperLine.includes('GIVEN') ||
        upperLine.includes('MIDDLE') ||
        upperLine.includes('NAME') ||
        upperLine.includes('SEX') ||
        upperLine.includes('DATE') ||
        upperLine.includes('BIRTH') ||
        upperLine.includes('CRN') ||
        /\d{4}[-\s]?\d{7}[-\s]?\d/.test(line) ||
        /\d{4}[\/\-]\d{2}[\/\-]\d{2}/.test(line) ||
        line.length < 5) {
      continue;
    }
    
    // Check if line contains address keywords
    const hasAddressKeyword = addressKeywords.some(keyword => 
      upperLine.includes(keyword)
    );
    
    // Check if line has numbers (house/street numbers)
    const hasNumbers = /\d+/.test(line);
    
    if (hasAddressKeyword || (hasNumbers && addressLines.length > 0)) {
      const cleaned = cleanAddressLine(line);
      
      if (cleaned.length >= 5) {
        addressLines.push(cleaned);
        console.log('üìç Added address line:', cleaned);
      }
    }
    
    // Stop after collecting enough address lines
    if (addressLines.length >= 4) {
      break;
    }
  }
  
  console.log('üì¶ Collected address lines:', addressLines);
  
  if (addressLines.length > 0) {
    // Fix common OCR errors in address
    const fullAddress = addressLines
      .map(line => line
        .replace(/ALOOCAN/g, 'CALOOCAN')
        .replace(/CRISTOBA\s/g, 'CRISTOBAL ')
        .replace(/PH\s*PP/g, 'PHILIPP')
        .replace(/AGONG/g, 'BAGONG')
      )
      .join(', ');
    
    console.log('‚úÖ Found Address:', fullAddress);
    return fullAddress;
  }
  
  console.log('‚ùå No UMID address found');
  return null;
};

/**
 * UMID ID Number (CRN) Extraction - IMPROVED VERSION
 * Handles OCR errors like "12151B0" instead of "1215160"
 */
const extractUMIDIDNumber = (lines) => {
  console.log('üî¢ Extracting UMID ID Number (CRN)');
  
  for (let line of lines) {
    console.log('üîç Checking line for CRN:', line);
    
    // Clean the line first - replace common OCR errors
    const cleanedLine = line
      .replace(/[Bb]/g, '8')  // B often misread for 8
      .replace(/[Oo]/g, '0')  // O often misread for 0
      .replace(/[Ll]/g, '1')  // L often misread for 1
      .replace(/[Ii]/g, '1')  // I often misread for 1
      .replace(/[Ss]/g, '5')  // S often misread for 5
      .replace(/[Zz]/g, '2'); // Z often misread for 2
    
    // Pattern 1: CRN followed by number
    // Format: CRN-XXXX-XXXXXXX-X or CRN XXXX-XXXXXXX-X
    const crnPattern = /CRN[-\s]*(\d{4})[-\s]?(\d{7})[-\s]?(\d)/i;
    const match = cleanedLine.match(crnPattern);
    
    if (match) {
      const idNumber = `${match[1]}-${match[2]}-${match[3]}`;
      console.log('‚úÖ Found UMID CRN:', idNumber);
      return idNumber;
    }
    
    // Pattern 2: Just the number pattern (without CRN label)
    // RN-XXXX-XXXXXXX-X (sometimes CRN reads as RN)
    const rnPattern = /RN[-\s]*(\d{4})[-\s]?(\d{7})[-\s]?(\d)/i;
    const rnMatch = cleanedLine.match(rnPattern);
    
    if (rnMatch) {
      const idNumber = `${rnMatch[1]}-${rnMatch[2]}-${rnMatch[3]}`;
      console.log('‚úÖ Found UMID ID (RN pattern):', idNumber);
      return idNumber;
    }
    
    // Pattern 3: Raw number pattern XXXX-XXXXXXX-X
    const numberPattern = /\b(\d{4})[-\s](\d{7})[-\s](\d)\b/;
    const numMatch = cleanedLine.match(numberPattern);
    
    if (numMatch) {
      const idNumber = `${numMatch[1]}-${numMatch[2]}-${numMatch[3]}`;
      console.log('‚úÖ Found UMID ID Number (raw):', idNumber);
      return idNumber;
    }
  }
  
  console.log('‚ùå No UMID ID number found');
  return null;
};
