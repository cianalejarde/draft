/**
 * Driver's License Sex Extraction - FIXED for M/F conversion
 */
const extractDriversLicenseSex = (lines) => {
  console.log('üë§ Extracting Driver\'s License Sex');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const nextLine = i + 1 < lines.length ? lines[i + 1] : '';
    
    console.log(`üîç Checking line ${i}: "${line}"`); // Debug log
    
    // ‚úÖ FIXED: Look for M or F in date line (most common pattern)
    // Pattern: "- M  2004,04/29" or "- F  2004,04/29"
    const sexBeforeDatePattern = /[-\s]*([MF])\s+\d{4}[,\/\-]\d{2}[\/\-]\d{2}/i;
    const sexMatch = line.match(sexBeforeDatePattern);
    
    if (sexMatch) {
      const sexLetter = sexMatch[1].toUpperCase();
      const sex = sexLetter === 'M' ? 'Male' : 'Female';
      console.log(`‚úÖ Found Sex (before date): ${sexLetter} ‚Üí ${sex}`);
      return sex;
    }
    
    // ‚úÖ Pattern 2: Look for isolated M or F near date/name context
    // Check if line contains just M or F with some context
    const isolatedSexPattern = /\b([MF])\b/gi;
    const isolatedMatches = line.match(isolatedSexPattern);
    
    if (isolatedMatches) {
      // Check if this line has date context (year pattern)
      const hasDateContext = /\d{4}/.test(line);
      
      if (hasDateContext) {
        const sexLetter = isolatedMatches[0].toUpperCase();
        const sex = sexLetter === 'M' ? 'Male' : 'Female';
        console.log(`‚úÖ Found Sex (with date context): ${sexLetter} ‚Üí ${sex}`);
        return sex;
      }
    }
    
    // ‚úÖ Pattern 3: Look for "SEX" label followed by M/F
    if (line.includes('SEX')) {
      // Check current line for M/F after "Sex"
      const labelSexMatch = line.match(/SEX[:\s]*([MF])/i);
      if (labelSexMatch) {
        const sexLetter = labelSexMatch[1].toUpperCase();
        const sex = sexLetter === 'M' ? 'Male' : 'Female';
        console.log(`‚úÖ Found Sex (after SEX label): ${sexLetter} ‚Üí ${sex}`);
        return sex;
      }
      
      // Check next line for M/F
      if (nextLine) {
        const nextSexMatch = nextLine.match(/^([MF])$/i);
        if (nextSexMatch) {
          const sexLetter = nextSexMatch[1].toUpperCase();
          const sex = sexLetter === 'M' ? 'Male' : 'Female';
          console.log(`‚úÖ Found Sex (next line after SEX): ${sexLetter} ‚Üí ${sex}`);
          return sex;
        }
      }
    }
    
    // ‚úÖ Pattern 4: Nationality line format
    // Format: "PHL M 2004/04/29" or "FILIPINO M 2004/04/29"
    const nationalityPattern = /^(PHL|FILIPINO)\s+([MF])\s+\d{4}[\/\-,]\d{2}[\/\-,]\d{2}/i;
    const nationalityMatch = line.match(nationalityPattern);
    if (nationalityMatch) {
      const sexLetter = nationalityMatch[2].toUpperCase();
      const sex = sexLetter === 'M' ? 'Male' : 'Female';
      console.log(`‚úÖ Found Sex (nationality pattern): ${sexLetter} ‚Üí ${sex}`);
      return sex;
    }
    
    // ‚úÖ Pattern 5: Check for M/F in lines that contain name or after name
    if (i > 0) {
      const prevLine = lines[i - 1];
      // If previous line had a name (comma pattern), check current line for M/F
      if (prevLine.includes(',') && /^[-\s]*([MF])\s/.test(line)) {
        const nameContextMatch = line.match(/^[-\s]*([MF])\s/);
        if (nameContextMatch) {
          const sexLetter = nameContextMatch[1].toUpperCase();
          const sex = sexLetter === 'M' ? 'Male' : 'Female';
          console.log(`‚úÖ Found Sex (after name line): ${sexLetter} ‚Üí ${sex}`);
          return sex;
        }
      }
    }
  }
  
  console.log('‚ùå No Driver\'s License sex found');
  return null;
};
